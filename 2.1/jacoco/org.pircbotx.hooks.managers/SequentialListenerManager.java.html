<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SequentialListenerManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx.hooks.managers</a> &gt; <span class="el_source">SequentialListenerManager.java</span></div><h1>SequentialListenerManager.java</h1><pre class="source lang-java linenums">// Generated by delombok at Sun Jan 24 05:08:02 EST 2016
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx.hooks.managers;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import java.io.Closeable;
import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import org.pircbotx.PircBotX;
import org.pircbotx.hooks.Event;
import org.pircbotx.hooks.Listener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * PircBotX receives and processes all input from the server in the &quot;bot/network
 * loop&quot;. As the input is parsed events are dispatched to this class.
 * &lt;p&gt;
 * Listeners are executed in insertion order. This provides a clear flow of
 * execution unlike other ListenerManagers. As a result, if needed this supports
 * completely single thread execution of PircBotX.
 * &lt;p&gt;
 * If a listener throws an Exception a ListenerExceptionEvent is dispatched. If
 * an exception is thrown when handling that event, the exception is logged to
 * prevent a potential StackOverflow.
 * &lt;p&gt;
 * As not all listeners should run in the network loop, this provides 3 listener
 * executors
 * &lt;ul&gt;
 * &lt;li&gt;Pooled (default for {@link #addListener(org.pircbotx.hooks.Listener) }) -
 * Run each event in the provided {@link #getExecutorPool() }. By default uses
 * the unbounded {@link Executors#newCachedThreadPool(java.util.concurrent.ThreadFactory)
 * }
 * but this means listeners can potentially run into synchronization issues.
 * Useful as mean loop will never deadlock&lt;/li&gt;
 * &lt;li&gt;Sequential - This executes the listener with one event at a time. This is
 * done in a {@link Executors#newSingleThreadExecutor(java.util.concurrent.ThreadFactory)
 * }. Any blocking calls (eg send(), WaitforQueue, querying an API on the
 * internet) will stall processing of further events for that listener. Useful
 * for logging and stats collection&lt;/li&gt;
 * &lt;li&gt;Inline - Executes listener in the bot loop. This has the smallest
 * overhead. Dangerous as blocking this thread could cause server timeouts.
 * Useful for bulk parsing and internal testing&lt;/li&gt;
 * &lt;/ul&gt;
 *
 *
 * @author Leon Blakey &lt;leon.m.blakey at gmail.com&gt;
 */
public class SequentialListenerManager extends AbstractListenerManager {
<span class="fc" id="L72">	private static final Logger log = LoggerFactory.getLogger(SequentialListenerManager.class);</span>
	
	/**
	 * Key: The actual listener, Value: The wrapper that calls it
	 */
<span class="fc" id="L77">	protected final LinkedList&lt;Listener&gt; listeners = Lists.newLinkedList();</span>
<span class="fc" id="L78">	protected final LinkedList&lt;ListenerExecutor&gt; listenerExecutors = Lists.newLinkedList();</span>
	
	/**
	 * Creates threads used in sequential listeners
	 */
	private final ThreadFactory sequentialThreadFactory;
	
	/**
	 * The default pool all pooled listeners are executed in
	 */
	private final Executor executorPool;

	@Override
	public void onEvent(Event event) {
<span class="fc" id="L92">		super.onEvent(event);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">		for (ListenerExecutor executor : listenerExecutors) {</span>
<span class="fc" id="L94">			executor.handleEvent(event);</span>
<span class="fc" id="L95">		}</span>
<span class="fc" id="L96">	}</span>

	/**
	 * Alias of {@link #appendListenerPooled(org.pircbotx.hooks.Listener) }
	 *
	 * @param listener
	 */
	@Override
	public void addListener(Listener listener) {
<span class="fc" id="L105">		addListenerPooled(listener);</span>
<span class="fc" id="L106">	}</span>

	/**
	 * Add listener to be executed in the &quot;bot/network loop&quot;
	 *
	 * @see SequentialListenerManager
	 */
	public SequentialListenerManager addListenerInline(Listener listener) {
<span class="fc" id="L114">		addListenerExecutor(listener, new InlineListenerExecutor(this, listener));</span>
<span class="fc" id="L115">		return this;</span>
	}

	/**
	 * Add listener to be executed in the main executor pool
	 *
	 * @see SequentialListenerManager
	 */
	public SequentialListenerManager addListenerPooled(Listener listener) {
<span class="fc" id="L124">		addListenerExecutor(listener, new PooledListenerExecutor(this, listener, executorPool));</span>
<span class="fc" id="L125">		return this;</span>
	}

	/**
	 * Add listener to be executed in the supplied executor pool
	 *
	 * @see SequentialListenerManager
	 */
	public SequentialListenerManager addListenerPooled(Listener listener, Executor suppliedPool) {
<span class="nc" id="L134">		addListenerExecutor(listener, new PooledListenerExecutor(this, listener, suppliedPool));</span>
<span class="nc" id="L135">		return this;</span>
	}

	/**
	 * Add listener to be executed in its sequential single thread
	 *
	 * @see SequentialListenerManager
	 */
	public SequentialListenerManager addListenerSequential(Listener listener) {
<span class="nc" id="L144">		addListenerExecutor(listener, new SequentialListenerExecutor(this, listener));</span>
<span class="nc" id="L145">		return this;</span>
	}

	/**
	 * Add a listener to be executed by the supplied executor
	 */
	public SequentialListenerManager addListenerExecutor(Listener listener, ListenerExecutor executor) {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">		if (listeners.contains(listener)) throw new IllegalArgumentException(&quot;Cannot add listener twice &quot; + listener);</span>
<span class="fc" id="L153">		listeners.add(listener);</span>
<span class="fc" id="L154">		listenerExecutors.add(executor);</span>
<span class="fc" id="L155">		return this;</span>
	}

	/**
	 * Add a listener at the given index to be executed by the supplied executor
	 */
	public SequentialListenerManager addListenerExecutor(int index, Listener listener, ListenerExecutor executor) {
<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (listeners.contains(listener)) throw new IllegalArgumentException(&quot;Cannot add listener twice &quot; + listener);</span>
<span class="nc" id="L163">		listeners.add(index, listener);</span>
<span class="nc" id="L164">		listenerExecutors.add(index, executor);</span>
<span class="nc" id="L165">		return this;</span>
	}

	/**
	 * Replace the executor for the supplied listener
	 */
	public SequentialListenerManager updateExecutor(Listener listener, ListenerExecutor executor) {
<span class="nc bnc" id="L172" title="All 2 branches missed.">		if (!listenerExists(listener)) throw new RuntimeException(&quot;Listener &quot; + listener + &quot; does not exist in this manager&quot;);</span>
<span class="nc" id="L173">		int index = listeners.indexOf(listener);</span>
<span class="nc" id="L174">		listenerExecutors.set(index, executor);</span>
<span class="nc" id="L175">		return this;</span>
	}

	/**
	 * Replace all executors with the inline executor
	 */
	public SequentialListenerManager updateExecutorAllInline() {
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		for (int i = 0; i &lt; listeners.size(); i++) {</span>
<span class="nc" id="L183">			Listener curListener = listeners.get(i);</span>
<span class="nc" id="L184">			listenerExecutors.set(i, new InlineListenerExecutor(this, curListener));</span>
		}
<span class="fc" id="L186">		return this;</span>
	}

	@Override
	public boolean removeListener(Listener listener) {
<span class="nc bnc" id="L191" title="All 2 branches missed.">		if (!listeners.contains(listener)) return false;</span>
<span class="nc" id="L192">		int index = listeners.indexOf(listener);</span>
<span class="nc" id="L193">		listeners.remove(index);</span>
<span class="nc" id="L194">		listenerExecutors.remove(index);</span>
<span class="nc" id="L195">		return true;</span>
	}

	public static interface ListenerExecutor extends Closeable {

		void handleEvent(Event event);
	}

	public static class InlineListenerExecutor implements ListenerExecutor {
		protected final AbstractListenerManager listenerManager;
		protected final Listener wrappedListener;

		@Override
		public void handleEvent(Event event) {
<span class="fc" id="L209">			listenerManager.executeListener(wrappedListener, event);</span>
<span class="fc" id="L210">		}</span>

		public void close() throws IOException {
			//Nothing to do, listener runs in bots thread
<span class="nc" id="L214">		}</span>

		@java.beans.ConstructorProperties({&quot;listenerManager&quot;, &quot;wrappedListener&quot;})
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L219">		public InlineListenerExecutor(final AbstractListenerManager listenerManager, final Listener wrappedListener) {</span>
<span class="fc" id="L220">			this.listenerManager = listenerManager;</span>
<span class="fc" id="L221">			this.wrappedListener = wrappedListener;</span>
<span class="fc" id="L222">		}</span>
	}

	public static class PooledListenerExecutor implements ListenerExecutor {
		protected final AbstractListenerManager listenerManager;
		protected final Listener wrappedListener;
		protected final Executor executor;

		@Override
		public void handleEvent(Event event) {
<span class="fc" id="L232">			executor.execute(new ExecuteListenerRunnable(listenerManager, wrappedListener, event));</span>
<span class="fc" id="L233">		}</span>

		public void close() throws IOException {
			//TODO: Blocking close or listener tracking
<span class="nc bnc" id="L237" title="All 2 branches missed.">			if (executor instanceof ExecutorService) ((ExecutorService)executor).shutdown();</span>
<span class="nc" id="L238">		}</span>

		@java.beans.ConstructorProperties({&quot;listenerManager&quot;, &quot;wrappedListener&quot;, &quot;executor&quot;})
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L243">		public PooledListenerExecutor(final AbstractListenerManager listenerManager, final Listener wrappedListener, final Executor executor) {</span>
<span class="fc" id="L244">			this.listenerManager = listenerManager;</span>
<span class="fc" id="L245">			this.wrappedListener = wrappedListener;</span>
<span class="fc" id="L246">			this.executor = executor;</span>
<span class="fc" id="L247">		}</span>
	}

	public static class SequentialListenerExecutor extends PooledListenerExecutor {

		public SequentialListenerExecutor(SequentialListenerManager listenerManager, Listener wrappedListener) {
<span class="nc" id="L253">			super(listenerManager, wrappedListener, Executors.newSingleThreadExecutor(listenerManager.getSequentialThreadFactory()));</span>
<span class="nc" id="L254">		}</span>
	}

	@Override
	public boolean listenerExists(Listener listener) {
<span class="nc" id="L259">		return listeners.contains(listener);</span>
	}

	@Override
	public ImmutableSet&lt;Listener&gt; getListeners() {
<span class="fc" id="L264">		return ImmutableSet.copyOf(listeners);</span>
	}

	@Override
	public void shutdown(PircBotX bot) {
		//TODO: Active listener tracking
<span class="nc bnc" id="L270" title="All 2 branches missed.">		if (executorPool instanceof ExecutorService) ((ExecutorService)executorPool).shutdown();</span>
<span class="nc" id="L271">	}</span>

	/**
	 * Create with 	 &lt;code&gt;
	 * executorPool = Executors.newCachedThreadPool();
	 * sequentialThreadFactory = Executors.defaultThreadFactory();
	 * &lt;/code&gt;
	 *
	 * @return
	 */
	public static SequentialListenerManager newDefault() {
<span class="fc" id="L282">		return builder().build();</span>
	}

	public static class SequentialListenerManagerBuilder {
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		private ThreadFactory sequentialThreadFactory;
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		private Executor executorPool;

<span class="fc" id="L293">		public SequentialListenerManagerBuilder() {</span>
<span class="fc" id="L294">			executorPool = Executors.newCachedThreadPool();</span>
<span class="fc" id="L295">			sequentialThreadFactory = Executors.defaultThreadFactory();</span>
			//Defaults for magic lombok builder
<span class="fc" id="L297">		}</span>

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public SequentialListenerManagerBuilder sequentialThreadFactory(final ThreadFactory sequentialThreadFactory) {
<span class="nc" id="L302">			this.sequentialThreadFactory = sequentialThreadFactory;</span>
<span class="nc" id="L303">			return this;</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public SequentialListenerManagerBuilder executorPool(final Executor executorPool) {
<span class="nc" id="L309">			this.executorPool = executorPool;</span>
<span class="nc" id="L310">			return this;</span>
		}

		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public SequentialListenerManager build() {
<span class="fc" id="L316">			return new SequentialListenerManager(sequentialThreadFactory, executorPool);</span>
		}

		@java.lang.Override
		@java.lang.SuppressWarnings(&quot;all&quot;)
		@javax.annotation.Generated(&quot;lombok&quot;)
		public java.lang.String toString() {
<span class="nc" id="L323">			return &quot;SequentialListenerManager.SequentialListenerManagerBuilder(sequentialThreadFactory=&quot; + this.sequentialThreadFactory + &quot;, executorPool=&quot; + this.executorPool + &quot;)&quot;;</span>
		}
	}

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L329">	SequentialListenerManager(final ThreadFactory sequentialThreadFactory, final Executor executorPool) {</span>
<span class="fc" id="L330">		this.sequentialThreadFactory = sequentialThreadFactory;</span>
<span class="fc" id="L331">		this.executorPool = executorPool;</span>
<span class="fc" id="L332">	}</span>

	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public static SequentialListenerManagerBuilder builder() {
<span class="fc" id="L337">		return new SequentialListenerManagerBuilder();</span>
	}

	/**
	 * Creates threads used in sequential listeners
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public ThreadFactory getSequentialThreadFactory() {
<span class="nc" id="L346">		return this.sequentialThreadFactory;</span>
	}

	/**
	 * The default pool all pooled listeners are executed in
	 */
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
	public Executor getExecutorPool() {
<span class="nc" id="L355">		return this.executorPool;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>