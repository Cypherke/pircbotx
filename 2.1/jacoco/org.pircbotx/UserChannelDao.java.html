<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>UserChannelDao.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pircbotx</a> &gt; <a href="index.source.html" class="el_package">org.pircbotx</a> &gt; <span class="el_source">UserChannelDao.java</span></div><h1>UserChannelDao.java</h1><pre class="source lang-java linenums">// Generated by delombok at Sun Jan 24 05:08:02 EST 2016
/**
 * Copyright (C) 2010-2014 Leon Blakey &lt;lord.quackstar at gmail.com&gt;
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.pircbotx;

import static com.google.common.base.Preconditions.*;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Maps;
import java.io.Closeable;
import java.util.EnumMap;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.pircbotx.exception.DaoException;
import org.pircbotx.hooks.events.UserListEvent;
import org.pircbotx.snapshot.ChannelSnapshot;
import org.pircbotx.snapshot.UserChannelDaoSnapshot;
import org.pircbotx.snapshot.UserChannelMapSnapshot;
import org.pircbotx.snapshot.UserSnapshot;

/**
 * Model that creates and tracks Users and Channel and maintains relationships.
 * This includes channel users, channel op/voice/etc users, private messages,
 * etc
 * &lt;p&gt;
 * All methods will throw a {@link NullPointerException} when any argument is
 * null
 *
 * @see User
 * @see Channel
 * @author Leon Blakey
 */
public class UserChannelDao&lt;U extends User, C extends Channel&gt; implements Closeable {
	protected final PircBotX bot;
	protected final Configuration.BotFactory botFactory;
	protected final Locale locale;
<span class="fc" id="L57">	protected final Object accessLock = new Object();</span>
	protected final UserChannelMap&lt;U, C&gt; mainMap;
	protected final EnumMap&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; levelsMap;
	protected final Map&lt;String, U&gt; userNickMap;
	protected final Map&lt;String, C&gt; channelNameMap;
	protected final Map&lt;String, U&gt; privateUsers;

<span class="fc" id="L64">	protected UserChannelDao(PircBotX bot, Configuration.BotFactory botFactory) {</span>
<span class="fc" id="L65">		this.bot = bot;</span>
<span class="fc" id="L66">		this.botFactory = botFactory;</span>
<span class="fc" id="L67">		this.locale = bot.getConfiguration().getLocale();</span>
<span class="fc" id="L68">		this.mainMap = new UserChannelMap&lt;U, C&gt;();</span>
<span class="fc" id="L69">		this.userNickMap = Maps.newHashMap();</span>
<span class="fc" id="L70">		this.channelNameMap = Maps.newHashMap();</span>
<span class="fc" id="L71">		this.privateUsers = Maps.newHashMap();</span>
		//Initialize levels map with a UserChannelMap for each level
<span class="fc" id="L73">		this.levelsMap = Maps.newEnumMap(UserLevel.class);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">		for (UserLevel level : UserLevel.values()) levelsMap.put(level, new UserChannelMap&lt;U, C&gt;());</span>
<span class="fc" id="L75">	}</span>

	/**
	 * Lookup user by nick, throwing a {@link DaoException} if not found
	 *
	 * @param nick The nick of the user
	 * @return Known active {@link User}
	 * @throws DaoException If user does not exist, exception will contain
	 * {@link org.pircbotx.exception.DaoException.Reason#UnknownUser} and the
	 * nick that doesn't exist
	 */
	public U getUser(@NonNull String nick) throws DaoException {
<span class="fc" id="L87">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">			if (nick == null) {</span>
<span class="nc" id="L89">				throw new java.lang.NullPointerException(&quot;nick&quot;);</span>
			}
<span class="fc" id="L91">			checkArgument(StringUtils.isNotBlank(nick), &quot;Cannot get a blank user&quot;);</span>
<span class="fc" id="L92">			U user = userNickMap.get(nick.toLowerCase(locale));</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">			if (user != null) return user;</span>
			//Does not exist
<span class="fc" id="L95">			throw new DaoException(DaoException.Reason.UnknownUser, nick);</span>
<span class="fc" id="L96">		}</span>
	}

	/**
	 * Lookup user by UserHostmask, throwing a {@link DaoException} if not found
	 *
	 * @param userHostmask The hostmask of the user
	 * @return Known active {@link User}
	 * @throws DaoException If user does not exist, exception will contain
	 * {@link org.pircbotx.exception.DaoException.Reason#UnknownUserHostmask},
	 * hostmask, and wrapped exception with nick
	 */
	public U getUser(@NonNull UserHostmask userHostmask) {
<span class="fc" id="L109">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">			if (userHostmask == null) {</span>
<span class="nc" id="L111">				throw new java.lang.NullPointerException(&quot;userHostmask&quot;);</span>
			}
			try {
				//Rarely we don't get the full hostmask
				//eg, the server setting your usermode when you connect to the server
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">				if (userHostmask.getNick() == null) return getUser(userHostmask.getHostmask());</span>
<span class="fc" id="L117">				return getUser(userHostmask.getNick());</span>
<span class="nc" id="L118">			} catch (Exception e) {</span>
				//Does not exist, wrap with detail about hostmask
<span class="nc" id="L120">				throw new DaoException(DaoException.Reason.UnknownUserHostmask, userHostmask.toString(), e);</span>
			}
<span class="nc" id="L122">		}</span>
	}

	/**
	 * Create a user from a hostmask, internally called when a valid, real user
	 * contacts us
	 *
	 * @param userHostmask The hostmask of the user
	 * @return Active {@link User} that was created
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public U createUser(@NonNull UserHostmask userHostmask) {
<span class="fc" id="L134">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">			if (userHostmask == null) {</span>
<span class="nc" id="L136">				throw new java.lang.NullPointerException(&quot;userHostmask&quot;);</span>
			}
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">			if (containsUser(userHostmask)) throw new RuntimeException(&quot;Cannot create a user from hostmask that already exists: &quot; + userHostmask);</span>
<span class="fc" id="L139">			U user = (U)botFactory.createUser(userHostmask);</span>
<span class="fc" id="L140">			userNickMap.put(userHostmask.getNick().toLowerCase(locale), user);</span>
<span class="fc" id="L141">			return user;</span>
<span class="nc" id="L142">		}</span>
	}

	/**
	 * @deprecated Renamed {@link #containsUser(java.lang.String) } to match
	 * Java Collections API
	 * @see #containsUser(java.lang.String)
	 */
	@Deprecated
	public boolean userExists(@NonNull String nick) {
<span class="fc" id="L152">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">			if (nick == null) {</span>
<span class="nc" id="L154">				throw new java.lang.NullPointerException(&quot;nick&quot;);</span>
			}
<span class="fc" id="L156">			return containsUser(nick);</span>
<span class="nc" id="L157">		}</span>
	}

	/**
	 * Check if user exists by nick
	 *
	 * @param nick Nick of user
	 * @return True if user exists
	 */
	public boolean containsUser(@NonNull String nick) {
<span class="fc" id="L167">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">			if (nick == null) {</span>
<span class="nc" id="L169">				throw new java.lang.NullPointerException(&quot;nick&quot;);</span>
			}
<span class="fc" id="L171">			String nickLowercase = nick.toLowerCase(locale);</span>
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">			return userNickMap.containsKey(nickLowercase) || privateUsers.containsKey(nickLowercase);</span>
<span class="nc" id="L173">		}</span>
	}

	/**
	 * Check if user exists by hostmask
	 *
	 * @param hostmask Hostmask of user
	 * @return True if user exists
	 */
	public boolean containsUser(@NonNull UserHostmask hostmask) {
<span class="fc" id="L183">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">			if (hostmask == null) {</span>
<span class="nc" id="L185">				throw new java.lang.NullPointerException(&quot;hostmask&quot;);</span>
			}
<span class="fc" id="L187">			return containsUser(hostmask.getNick());</span>
<span class="nc" id="L188">		}</span>
	}

	/**
	 * Get all currently known users, except from just joined channels where the
	 * WHO response hasn't finished (listen for {@link UserListEvent} instead)
	 *
	 * @return An immutable set of the currently known users
	 * @see UserListEvent
	 */
	public ImmutableSortedSet&lt;U&gt; getAllUsers() {
<span class="fc" id="L199">		synchronized (this.accessLock) {</span>
<span class="fc" id="L200">			return ImmutableSortedSet.copyOf(userNickMap.values());</span>
<span class="nc" id="L201">		}</span>
	}

	protected void addUserToChannel(@NonNull U user, @NonNull C channel) {
<span class="fc" id="L205">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L207">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L210">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L212">			mainMap.addUserToChannel(user, channel);</span>
<span class="pc" id="L213">		}</span>
<span class="fc" id="L214">	}</span>

	protected void addUserToPrivate(@NonNull U user) {
<span class="fc" id="L217">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L219">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L221">			String nick = user.getNick().toLowerCase(locale);</span>
<span class="fc" id="L222">			privateUsers.put(nick, user);</span>
<span class="pc" id="L223">		}</span>
<span class="fc" id="L224">	}</span>

	protected void addUserToLevel(@NonNull UserLevel level, @NonNull U user, @NonNull C channel) {
<span class="fc" id="L227">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L229">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L232">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L235">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L237">			levelsMap.get(level).addUserToChannel(user, channel);</span>
<span class="pc" id="L238">		}</span>
<span class="fc" id="L239">	}</span>

	protected void removeUserFromLevel(@NonNull UserLevel level, @NonNull U user, @NonNull C channel) {
<span class="fc" id="L242">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L244">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L247">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L250">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L252">			levelsMap.get(level).removeUserFromChannel(user, channel);</span>
<span class="pc" id="L253">		}</span>
<span class="fc" id="L254">	}</span>

	/**
	 * Gets all currently known users in a channel who do not hold a UserLevel
	 * (op/voice/etc). A {@link UserListEvent} for the channel must of been
	 * dispatched before this method will return complete results
	 *
	 * @param channel Known channel
	 * @return An immutable sorted set of Users
	 */
	public ImmutableSortedSet&lt;U&gt; getNormalUsers(@NonNull C channel) {
<span class="nc" id="L265">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L267">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc" id="L269">			Set&lt;U&gt; remainingUsers = new HashSet&lt;U&gt;(mainMap.getUsers(channel));</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) remainingUsers.removeAll(curLevelMap.getUsers(channel));</span>
<span class="nc" id="L271">			return ImmutableSortedSet.copyOf(remainingUsers);</span>
<span class="nc" id="L272">		}</span>
	}

	/**
	 * Gets all currently known users in a channel that hold the specified
	 * UserLevel. A {@link UserListEvent} for the channel must of been
	 * dispatched before this method will return complete results
	 *
	 * @param channel Known channel
	 * @param level Level users must hold
	 * @return An immutable sorted set of Users
	 */
	public ImmutableSortedSet&lt;U&gt; getUsers(@NonNull C channel, @NonNull UserLevel level) {
<span class="nc" id="L285">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L287">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc bnc" id="L289" title="All 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L290">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="nc" id="L292">			return levelsMap.get(level).getUsers(channel);</span>
<span class="nc" id="L293">		}</span>
	}

	/**
	 * Gets all currently known levels (op/voice/etc) a user holds in the
	 * channel. A {@link UserListEvent} for the channel must of been dispatched
	 * before this method will return complete results
	 *
	 * @param channel Known channel
	 * @param user Known user
	 * @return An immutable sorted set of UserLevels
	 */
	public ImmutableSortedSet&lt;UserLevel&gt; getLevels(@NonNull C channel, @NonNull U user) {
<span class="nc" id="L306">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L308">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc bnc" id="L310" title="All 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L311">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="nc" id="L313">			ImmutableSortedSet.Builder&lt;UserLevel&gt; builder = ImmutableSortedSet.naturalOrder();</span>
<span class="nc bnc" id="L314" title="All 4 branches missed.">			for (Map.Entry&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; curEntry : levelsMap.entrySet()) if (curEntry.getValue().containsEntry(user, channel)) builder.add(curEntry.getKey());</span>
<span class="nc" id="L315">			return builder.build();</span>
<span class="nc" id="L316">		}</span>
	}

	/**
	 * Gets all currently known channels the user is a part of as a normal user.
	 * A {@link UserListEvent} for all channels must of been dispatched before
	 * this method will return complete results
	 *
	 * @param user Known user
	 * @return An immutable sorted set of Channels
	 */
	public ImmutableSortedSet&lt;C&gt; getNormalUserChannels(@NonNull U user) {
<span class="nc" id="L328">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L330">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="nc" id="L332">			Set&lt;C&gt; remainingChannels = new HashSet&lt;C&gt;(mainMap.getChannels(user));</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) remainingChannels.removeAll(curLevelMap.getChannels(user));</span>
<span class="nc" id="L334">			return ImmutableSortedSet.copyOf(remainingChannels);</span>
<span class="nc" id="L335">		}</span>
	}

	/**
	 * Gets all currently known channels the user is a part of with the
	 * specified level. A {@link UserListEvent} for all channels must of been
	 * dispatched before this method will return complete results
	 *
	 * @param user Known user
	 * @return An immutable sorted set of Channels
	 */
	public ImmutableSortedSet&lt;C&gt; getChannels(@NonNull U user, @NonNull UserLevel level) {
<span class="fc" id="L347">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L349">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L352">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="fc" id="L354">			return levelsMap.get(level).getChannels(user);</span>
<span class="nc" id="L355">		}</span>
	}

	protected void removeUserFromChannel(@NonNull U user, @NonNull C channel) {
<span class="fc" id="L359">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L361">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L364">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L366">			mainMap.removeUserFromChannel(user, channel);</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.removeUserFromChannel(user, channel);</span>
<span class="pc bpc" id="L368" title="2 of 4 branches missed.">			if (!privateUsers.values().contains(user) &amp;&amp; !mainMap.containsUser(user)) </span>
			//Completely remove user
<span class="fc" id="L370">			userNickMap.remove(user.getNick().toLowerCase(locale));</span>
<span class="pc" id="L371">		}</span>
<span class="fc" id="L372">	}</span>

	protected void removeUser(@NonNull U user) {
<span class="fc" id="L375">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L377">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L379">			mainMap.removeUser(user);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.removeUser(user);</span>
			//Remove remaining locations
<span class="fc" id="L382">			userNickMap.remove(user.getNick().toLowerCase(locale));</span>
<span class="fc" id="L383">			privateUsers.remove(user.getNick().toLowerCase(locale));</span>
<span class="pc" id="L384">		}</span>
<span class="fc" id="L385">	}</span>

	protected boolean levelContainsUser(@NonNull UserLevel level, @NonNull C channel, @NonNull U user) {
<span class="fc" id="L388">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">			if (level == null) {</span>
<span class="nc" id="L390">				throw new java.lang.NullPointerException(&quot;level&quot;);</span>
			}
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L393">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L396">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L398">			return levelsMap.get(level).containsEntry(user, channel);</span>
<span class="nc" id="L399">		}</span>
	}

	protected void renameUser(@NonNull U user, @NonNull String newNick) {
<span class="fc" id="L403">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L405">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">			if (newNick == null) {</span>
<span class="nc" id="L408">				throw new java.lang.NullPointerException(&quot;newNick&quot;);</span>
			}
<span class="fc" id="L410">			String oldNick = user.getNick();</span>
<span class="fc" id="L411">			user.setNick(newNick);</span>
<span class="fc" id="L412">			userNickMap.remove(oldNick.toLowerCase(locale));</span>
<span class="fc" id="L413">			userNickMap.put(newNick.toLowerCase(locale), user);</span>
<span class="pc" id="L414">		}</span>
<span class="fc" id="L415">	}</span>

	/**
	 * Lookup channel by name, throwing a {@link DaoException} if not found
	 *
	 * @param name Name of channel (eg #pircbotx)
	 * @return A known channel
	 */
	public C getChannel(@NonNull String name) throws DaoException {
<span class="fc" id="L424">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">			if (name == null) {</span>
<span class="nc" id="L426">				throw new java.lang.NullPointerException(&quot;name&quot;);</span>
			}
<span class="fc" id="L428">			checkArgument(StringUtils.isNotBlank(name), &quot;Cannot get a blank channel&quot;);</span>
<span class="fc" id="L429">			C chan = channelNameMap.get(name.toLowerCase(locale));</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">			if (chan != null) return chan;</span>
			//This could potentially be a mode message, strip off prefixes till we get a channel
<span class="fc" id="L432">			String modePrefixes = bot.getConfiguration().getUserLevelPrefixes();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">			if (modePrefixes.contains(Character.toString(name.charAt(0)))) {</span>
<span class="fc" id="L434">				String nameTrimmed = name.toLowerCase(locale);</span>
				do {
<span class="fc" id="L436">					nameTrimmed = nameTrimmed.substring(1);</span>
<span class="fc" id="L437">					chan = channelNameMap.get(nameTrimmed);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">					if (chan != null) return chan;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">				}				 while (modePrefixes.contains(Character.toString(nameTrimmed.charAt(0))));</span>
			}
			//Channel does not exist
<span class="fc" id="L442">			throw new DaoException(DaoException.Reason.UnknownChannel, name);</span>
<span class="fc" id="L443">		}</span>
	}

	/**
	 * Creates a known channel, internally called when we join a channel
	 *
	 * @param name
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public C createChannel(@NonNull String name) {
<span class="fc" id="L453">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">			if (name == null) {</span>
<span class="nc" id="L455">				throw new java.lang.NullPointerException(&quot;name&quot;);</span>
			}
<span class="fc" id="L457">			C chan = (C)botFactory.createChannel(bot, name);</span>
<span class="fc" id="L458">			channelNameMap.put(name.toLowerCase(locale), chan);</span>
<span class="fc" id="L459">			return chan;</span>
<span class="nc" id="L460">		}</span>
	}

	/**
	 * @deprecated Renamed {@link #containsChannel(java.lang.String) } to match
	 * the Java Collections API
	 * @see #containsChannel(java.lang.String)
	 */
	@Deprecated
	public boolean channelExists(@NonNull String name) {
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">		if (name == null) {</span>
<span class="nc" id="L471">			throw new java.lang.NullPointerException(&quot;name&quot;);</span>
		}
<span class="fc" id="L473">		return containsChannel(name);</span>
	}

	/**
	 * Check if we are currently in the given channel
	 *
	 * @param name Channel name (eg #pircbotx)
	 * @return True if we are still connected to the channel
	 */
	public boolean containsChannel(@NonNull String name) {
<span class="fc" id="L483">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">			if (name == null) {</span>
<span class="nc" id="L485">				throw new java.lang.NullPointerException(&quot;name&quot;);</span>
			}
<span class="fc bfc" id="L487" title="All 2 branches covered.">			if (channelNameMap.containsKey(name.toLowerCase(locale))) return true;</span>
			//This could potentially be a mode message, strip off prefixes till we get a channel
<span class="fc" id="L489">			String modePrefixes = bot.getConfiguration().getUserLevelPrefixes();</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">			if (modePrefixes.contains(Character.toString(name.charAt(0)))) {</span>
<span class="fc" id="L491">				String nameTrimmed = name.toLowerCase(locale);</span>
				do {
<span class="fc" id="L493">					nameTrimmed = nameTrimmed.substring(1);</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">					if (channelNameMap.containsKey(nameTrimmed)) return true;</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">				}				 while (modePrefixes.contains(Character.toString(nameTrimmed.charAt(0))));</span>
			}
			//Nope, doesn't exist
<span class="fc" id="L498">			return false;</span>
<span class="nc" id="L499">		}</span>
	}

	/**
	 * Get all currently known users in a channel
	 *
	 * @param channel Known channel
	 * @return An immutable set of users
	 */
	public ImmutableSortedSet&lt;U&gt; getUsers(@NonNull C channel) {
<span class="fc" id="L509">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L511">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="fc" id="L513">			return mainMap.getUsers(channel);</span>
<span class="nc" id="L514">		}</span>
	}

	/**
	 * Get all currently joined channels
	 *
	 * @return An immutable set of channels
	 */
	public ImmutableSortedSet&lt;C&gt; getAllChannels() {
<span class="fc" id="L523">		synchronized (this.accessLock) {</span>
<span class="fc" id="L524">			return ImmutableSortedSet.copyOf(channelNameMap.values());</span>
<span class="nc" id="L525">		}</span>
	}

	/**
	 * Get &lt;i&gt;channels we're joined to&lt;/i&gt; that the user is joined to as well
	 *
	 * @param user A known user
	 * @return An immutable set of channels
	 */
	public ImmutableSortedSet&lt;C&gt; getChannels(@NonNull U user) {
<span class="fc" id="L535">		synchronized (this.accessLock) {</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">			if (user == null) {</span>
<span class="nc" id="L537">				throw new java.lang.NullPointerException(&quot;user&quot;);</span>
			}
<span class="fc" id="L539">			return mainMap.getChannels(user);</span>
<span class="nc" id="L540">		}</span>
	}

	protected void removeChannel(@NonNull C channel) {
<span class="nc" id="L544">		synchronized (this.accessLock) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">			if (channel == null) {</span>
<span class="nc" id="L546">				throw new java.lang.NullPointerException(&quot;channel&quot;);</span>
			}
<span class="nc" id="L548">			mainMap.removeChannel(channel);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.removeChannel(channel);</span>
			//Remove remaining locations
<span class="nc" id="L551">			channelNameMap.remove(channel.getName());</span>
<span class="nc" id="L552">		}</span>
<span class="nc" id="L553">	}</span>

	/**
	 * Gets the bots own user object.
	 *
	 * @return The user object representing this bot
	 */
	public User getUserBot() {
<span class="nc" id="L561">		synchronized (this.accessLock) {</span>
<span class="nc" id="L562">			return getUser(bot.getNick());</span>
<span class="nc" id="L563">		}</span>
	}

	/**
	 * Clears all internal maps
	 */
	public void close() {
<span class="fc" id="L570">		synchronized (this.accessLock) {</span>
<span class="fc" id="L571">			mainMap.clear();</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">			for (UserChannelMap&lt;U, C&gt; curLevelMap : levelsMap.values()) curLevelMap.clear();</span>
<span class="fc" id="L573">			channelNameMap.clear();</span>
<span class="fc" id="L574">			privateUsers.clear();</span>
<span class="fc" id="L575">			userNickMap.clear();</span>
<span class="pc" id="L576">		}</span>
<span class="fc" id="L577">	}</span>

	/**
	 * Create an immutable snapshot (copy) of all of contained Users, Channels,
	 * and mappings, VERY EXPENSIVE.
	 *
	 * @return Copy of entire model
	 */
	public UserChannelDaoSnapshot createSnapshot() {
<span class="fc" id="L586">		synchronized (this.accessLock) {</span>
			//Create snapshots of all users and channels
<span class="fc" id="L588">			Map&lt;U, UserSnapshot&gt; userSnapshotMap = Maps.newHashMapWithExpectedSize(userNickMap.size());</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">			for (U curUser : userNickMap.values()) userSnapshotMap.put(curUser, curUser.createSnapshot());</span>
<span class="fc" id="L590">			Map&lt;C, ChannelSnapshot&gt; channelSnapshotMap = Maps.newHashMapWithExpectedSize(channelNameMap.size());</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">			for (C curChannel : channelNameMap.values()) channelSnapshotMap.put(curChannel, curChannel.createSnapshot());</span>
			//Make snapshots of the relationship maps using the above user and channel snapshots
<span class="fc" id="L593">			UserChannelMapSnapshot mainMapSnapshot = mainMap.createSnapshot(userSnapshotMap, channelSnapshotMap);</span>
<span class="fc" id="L594">			EnumMap&lt;UserLevel, UserChannelMap&lt;UserSnapshot, ChannelSnapshot&gt;&gt; levelsMapSnapshot = Maps.newEnumMap(UserLevel.class);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">			for (Map.Entry&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; curLevel : levelsMap.entrySet()) levelsMapSnapshot.put(curLevel.getKey(), curLevel.getValue().createSnapshot(userSnapshotMap, channelSnapshotMap));</span>
<span class="fc" id="L596">			ImmutableBiMap.Builder&lt;String, UserSnapshot&gt; userNickMapSnapshotBuilder = ImmutableBiMap.builder();</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">			for (Map.Entry&lt;String, U&gt; curNickEntry : userNickMap.entrySet()) userNickMapSnapshotBuilder.put(curNickEntry.getKey(), userSnapshotMap.get(curNickEntry.getValue()));</span>
<span class="fc" id="L598">			ImmutableBiMap.Builder&lt;String, ChannelSnapshot&gt; channelNameMapSnapshotBuilder = ImmutableBiMap.builder();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">			for (Map.Entry&lt;String, C&gt; curName : channelNameMap.entrySet()) channelNameMapSnapshotBuilder.put(curName.getKey(), channelSnapshotMap.get(curName.getValue()));</span>
<span class="fc" id="L600">			ImmutableBiMap.Builder&lt;String, UserSnapshot&gt; privateUserSnapshotBuilder = ImmutableBiMap.builder();</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">			for (Map.Entry&lt;String, U&gt; curNickEntry : privateUsers.entrySet()) privateUserSnapshotBuilder.put(curNickEntry.getKey(), userSnapshotMap.get(curNickEntry.getValue()));</span>
			//Finally can create the snapshot object
<span class="fc" id="L603">			UserChannelDaoSnapshot daoSnapshot = new UserChannelDaoSnapshot(bot, locale, mainMapSnapshot, levelsMapSnapshot, userNickMapSnapshotBuilder.build(), channelNameMapSnapshotBuilder.build(), privateUserSnapshotBuilder.build());</span>
			//Tell UserSnapshots and ChannelSnapshots what the new backing dao is
<span class="fc bfc" id="L605" title="All 2 branches covered.">			for (UserSnapshot curUserSnapshot : userSnapshotMap.values()) curUserSnapshot.setDao(daoSnapshot);</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">			for (ChannelSnapshot curChannelSnapshot : channelSnapshotMap.values()) curChannelSnapshot.setDao(daoSnapshot);</span>
			//Finally
<span class="fc" id="L608">			return daoSnapshot;</span>
<span class="nc" id="L609">		}</span>
	}

	@java.beans.ConstructorProperties({&quot;bot&quot;, &quot;botFactory&quot;, &quot;locale&quot;, &quot;mainMap&quot;, &quot;levelsMap&quot;, &quot;userNickMap&quot;, &quot;channelNameMap&quot;, &quot;privateUsers&quot;})
	@java.lang.SuppressWarnings(&quot;all&quot;)
	@javax.annotation.Generated(&quot;lombok&quot;)
<span class="fc" id="L615">	protected UserChannelDao(final PircBotX bot, final Configuration.BotFactory botFactory, final Locale locale, final UserChannelMap&lt;U, C&gt; mainMap, final EnumMap&lt;UserLevel, UserChannelMap&lt;U, C&gt;&gt; levelsMap, final Map&lt;String, U&gt; userNickMap, final Map&lt;String, C&gt; channelNameMap, final Map&lt;String, U&gt; privateUsers) {</span>
<span class="fc" id="L616">		this.bot = bot;</span>
<span class="fc" id="L617">		this.botFactory = botFactory;</span>
<span class="fc" id="L618">		this.locale = locale;</span>
<span class="fc" id="L619">		this.mainMap = mainMap;</span>
<span class="fc" id="L620">		this.levelsMap = levelsMap;</span>
<span class="fc" id="L621">		this.userNickMap = userNickMap;</span>
<span class="fc" id="L622">		this.channelNameMap = channelNameMap;</span>
<span class="fc" id="L623">		this.privateUsers = privateUsers;</span>
<span class="fc" id="L624">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>