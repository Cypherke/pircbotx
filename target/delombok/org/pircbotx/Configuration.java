// Generated by delombok at Sun Jul 12 21:25:30 UTC 2015
/**
 * Copyright (C) 2010-2014 Leon Blakey <lord.quackstar at gmail.com>
 *
 * This file is part of PircBotX.
 *
 * PircBotX is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * PircBotX is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * PircBotX. If not, see <http://www.gnu.org/licenses/>.
 */
package org.pircbotx;

import static com.google.common.base.Preconditions.*;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.nio.charset.Charset;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import javax.net.SocketFactory;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;
import org.pircbotx.cap.CapHandler;
import org.pircbotx.cap.EnableCapHandler;
import org.pircbotx.dcc.DccHandler;
import org.pircbotx.dcc.ReceiveChat;
import org.pircbotx.dcc.ReceiveFileTransfer;
import org.pircbotx.dcc.SendChat;
import org.pircbotx.dcc.SendFileTransfer;
import org.pircbotx.exception.IrcException;
import org.pircbotx.hooks.CoreHooks;
import org.pircbotx.hooks.Listener;
import org.pircbotx.hooks.managers.ListenerManager;
import org.pircbotx.hooks.managers.ThreadedListenerManager;
import org.pircbotx.output.OutputCAP;
import org.pircbotx.output.OutputChannel;
import org.pircbotx.output.OutputDCC;
import org.pircbotx.output.OutputIRC;
import org.pircbotx.output.OutputRaw;
import org.pircbotx.output.OutputUser;

/**
 * Immutable configuration for PircBotX created from
 * {@link Configuration.Builder}
 *
 * @author Leon Blakey
 */
public class Configuration {
	//WebIRC
	protected final boolean webIrcEnabled;
	protected final String webIrcUsername;
	protected final String webIrcHostname;
	protected final InetAddress webIrcAddress;
	protected final String webIrcPassword;
	//Bot information
	protected final String name;
	protected final String login;
	protected final String version;
	protected final String finger;
	protected final String realName;
	protected final String channelPrefixes;
	protected final String userLevelPrefixes;
	protected final boolean snapshotsEnabled;
	//DCC
	protected final boolean dccFilenameQuotes;
	protected final ImmutableList<Integer> dccPorts;
	protected final InetAddress dccLocalAddress;
	protected final int dccAcceptTimeout;
	protected final int dccResumeAcceptTimeout;
	protected final int dccTransferBufferSize;
	protected final boolean dccPassiveRequest;
	//Connect information
	protected final ImmutableList<ServerEntry> servers;
	protected final String serverPassword;
	protected final SocketFactory socketFactory;
	protected final InetAddress localAddress;
	protected final Charset encoding;
	protected final Locale locale;
	protected final int socketTimeout;
	protected final int maxLineLength;
	protected final boolean autoSplitMessage;
	protected final boolean autoNickChange;
	protected final long messageDelay;
	protected final boolean shutdownHookEnabled;
	protected final ImmutableMap<String, String> autoJoinChannels;
	protected final boolean identServerEnabled;
	protected final String nickservPassword;
	protected final String nickservOnSuccess;
	protected final String nickservNick;
	protected final boolean nickservDelayJoin;
	protected final boolean autoReconnect;
	protected final int autoReconnectDelay;
	protected final int autoReconnectAttempts;
	//Bot classes
	protected final ListenerManager listenerManager;
	protected final boolean capEnabled;
	protected final ImmutableList<CapHandler> capHandlers;
	protected final ImmutableSortedMap<Character, ChannelModeHandler> channelModeHandlers;
	protected final BotFactory botFactory;

	/**
	 * Use {@link Configuration.Builder#buildConfiguration() }.
	 *
	 * @param builder
	 * @see Configuration.Builder#buildConfiguration()
	 */
	protected Configuration(Builder builder) {
		//Check for basics
		if (builder.isWebIrcEnabled()) {
			checkNotNull(builder.getWebIrcAddress(), "Must specify WEBIRC address if enabled");
			checkArgument(StringUtils.isNotBlank(builder.getWebIrcHostname()), "Must specify WEBIRC hostname if enabled");
			checkArgument(StringUtils.isNotBlank(builder.getWebIrcUsername()), "Must specify WEBIRC username if enabled");
			checkArgument(StringUtils.isNotBlank(builder.getWebIrcPassword()), "Must specify WEBIRC password if enabled");
		}
		checkArgument(StringUtils.isNotBlank(builder.getName()), "Must specify name");
		checkArgument(StringUtils.isNotBlank(builder.getLogin()), "Must specify login");
		checkArgument(StringUtils.isNotBlank(builder.getVersion()), "Must specify version");
		checkArgument(StringUtils.isNotBlank(builder.getFinger()), "Must specify finger");
		checkArgument(StringUtils.isNotBlank(builder.getRealName()), "Must specify realName");
		checkArgument(StringUtils.isNotBlank(builder.getChannelPrefixes()), "Must specify channel prefixes");
		checkNotNull(StringUtils.isNotBlank(builder.getUserLevelPrefixes()), "Channel mode message prefixes cannot be null");
		checkNotNull(builder.getDccPorts(), "DCC ports list cannot be null");
		checkArgument(builder.getDccAcceptTimeout() > 0, "dccAcceptTimeout must be positive");
		checkArgument(builder.getDccResumeAcceptTimeout() > 0, "dccResumeAcceptTimeout must be positive");
		checkArgument(builder.getDccTransferBufferSize() > 0, "dccTransferBufferSize must be positive");
		checkNotNull(builder.getServers(), "Servers list cannot be null");
		checkArgument(!builder.getServers().isEmpty(), "Must specify servers to connect to");
		for (ServerEntry serverEntry : builder.getServers()) {
			checkArgument(StringUtils.isNotBlank(serverEntry.getHostname()), "Must specify server hostname");
			checkArgument(serverEntry.getPort() > 0 && serverEntry.getPort() <= 65535, "Port must be between 1 and 65535");
		}
		checkNotNull(builder.getSocketFactory(), "Socket factory cannot be null");
		checkNotNull(builder.getEncoding(), "Encoding cannot be null");
		checkNotNull(builder.getLocale(), "Locale cannot be null");
		checkArgument(builder.getSocketTimeout() > 0, "Socket timeout must greater than 0");
		checkArgument(builder.getMaxLineLength() > 0, "Max line length must be positive");
		checkArgument(builder.getMessageDelay() >= 0, "Message delay must be positive");
		checkNotNull(builder.getAutoJoinChannels(), "Auto join channels map cannot be null");
		for (Map.Entry<String, String> curEntry : builder.getAutoJoinChannels().entrySet()) if (StringUtils.isBlank(curEntry.getKey())) throw new RuntimeException("Channel must not be blank");
		if (builder.getNickservPassword() != null) checkArgument(StringUtils.isNotBlank(builder.getNickservPassword()), "Nickserv password cannot be empty");
		checkArgument(StringUtils.isNotBlank(builder.getNickservOnSuccess()), "Nickserv on success cannot be blank");
		checkArgument(StringUtils.isNotBlank(builder.getNickservNick()), "Nickserv nick cannot be blank");
		checkArgument(builder.getAutoReconnectAttempts() > 0, "setAutoReconnectAttempts must be greater than 0");
		checkArgument(builder.getAutoReconnectDelay() >= 0, "setAutoReconnectDelay must be positive or 0");
		checkNotNull(builder.getListenerManager(), "Must specify listener manager");
		checkNotNull(builder.getCapHandlers(), "Cap handlers list cannot be null");
		checkNotNull(builder.getChannelModeHandlers(), "Channel mode handlers list cannot be null");
		checkNotNull(builder.getBotFactory(), "Must specify bot factory");
		this.webIrcEnabled = builder.isWebIrcEnabled();
		this.webIrcUsername = builder.getWebIrcUsername();
		this.webIrcHostname = builder.getWebIrcHostname();
		this.webIrcAddress = builder.getWebIrcAddress();
		this.webIrcPassword = builder.getWebIrcPassword();
		this.name = builder.getName();
		this.login = builder.getLogin();
		this.version = builder.getVersion();
		this.finger = builder.getFinger();
		this.realName = builder.getRealName();
		this.channelPrefixes = builder.getChannelPrefixes().trim();
		this.userLevelPrefixes = builder.getUserLevelPrefixes().trim();
		this.snapshotsEnabled = builder.isSnapshotsEnabled();
		this.dccFilenameQuotes = builder.isDccFilenameQuotes();
		this.dccPorts = ImmutableList.copyOf(builder.getDccPorts());
		this.dccLocalAddress = builder.getDccLocalAddress();
		this.dccAcceptTimeout = builder.getDccAcceptTimeout();
		this.dccResumeAcceptTimeout = builder.getDccResumeAcceptTimeout();
		this.dccTransferBufferSize = builder.getDccTransferBufferSize();
		this.dccPassiveRequest = builder.isDccPassiveRequest();
		this.servers = ImmutableList.copyOf(builder.getServers());
		this.serverPassword = builder.getServerPassword();
		this.socketFactory = builder.getSocketFactory();
		this.localAddress = builder.getLocalAddress();
		this.encoding = builder.getEncoding();
		this.locale = builder.getLocale();
		this.socketTimeout = builder.getSocketTimeout();
		this.maxLineLength = builder.getMaxLineLength();
		this.autoSplitMessage = builder.isAutoSplitMessage();
		this.autoNickChange = builder.isAutoNickChange();
		this.messageDelay = builder.getMessageDelay();
		this.identServerEnabled = builder.isIdentServerEnabled();
		this.nickservPassword = builder.getNickservPassword();
		this.nickservOnSuccess = builder.getNickservOnSuccess();
		this.nickservNick = builder.getNickservNick();
		this.nickservDelayJoin = builder.isNickservDelayJoin();
		this.autoReconnect = builder.isAutoReconnect();
		this.autoReconnectDelay = builder.getAutoReconnectDelay();
		this.autoReconnectAttempts = builder.getAutoReconnectAttempts();
		this.listenerManager = builder.getListenerManager();
		this.autoJoinChannels = ImmutableMap.copyOf(builder.getAutoJoinChannels());
		this.capEnabled = builder.isCapEnabled();
		this.capHandlers = ImmutableList.copyOf(builder.getCapHandlers());
		ImmutableSortedMap.Builder<Character, ChannelModeHandler> channelModeHandlersBuilder = ImmutableSortedMap.naturalOrder();
		for (ChannelModeHandler curHandler : builder.getChannelModeHandlers()) channelModeHandlersBuilder.put(curHandler.getMode(), curHandler);
		this.channelModeHandlers = channelModeHandlersBuilder.build();
		this.shutdownHookEnabled = builder.isShutdownHookEnabled();
		this.botFactory = builder.getBotFactory();
	}

	@SuppressWarnings("unchecked")
	public <M extends ListenerManager> M getListenerManager() {
		return (M)listenerManager;
	}

	/**
	 * Builder to create an immutable {@link Configuration}.
	 */
	public static class Builder {
		//WebIRC
		/**
		 * Enable or disable sending WEBIRC line on connect, default disabled
		 */
		protected boolean webIrcEnabled = false;
		
		/**
		 * Username of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		protected String webIrcUsername = null;
		
		/**
		 * Hostname of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		protected String webIrcHostname = null;
		
		/**
		 * IP address of WEBIRC connection, must be set if WEBIRC is enabled
		 */
		protected InetAddress webIrcAddress = null;
		
		/**
		 * Password of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		protected String webIrcPassword = null;
		//Bot information
		/**
		 * The nick to be used for the IRC connection (nick!login@host), must
		 * not be blank
		 */
		protected String name;
		
		/**
		 * The login to be used for the IRC connection (nick!login@host),
		 * default PircBotX
		 */
		protected String login = "PircBotX";
		
		/**
		 * CTCP version response.
		 */
		protected String version = "PircBotX " + PircBotX.VERSION + " Java IRC bot - pircbotx.googlecode.com";
		
		/**
		 * CTCP finger response
		 */
		protected String finger = "You ought to be arrested for fingering a bot!";
		
		/**
		 * The realName/fullname used for WHOIS info, defaults to version
		 */
		protected String realName = version;
		
		/**
		 * Allowed channel prefix characters, default <code>#&+!</code>
		 */
		protected String channelPrefixes = "#&+!";
		
		/**
		 * Supported channel prefixes that restrict a sent message to users with
		 * this mode, eg <code>PRIVMSG +#channel :hello</code> will only send a
		 * message to voiced or higher users, default <code>+@%&~!</code>
		 */
		protected String userLevelPrefixes = UserLevel.getSymbols() + "!";
		
		/**
		 * Enable creation of snapshots, default true. In bulk datasets or very
		 * lower power devices, creating snapshots can be a relatively expensive
		 * operation for every
		 * {@link org.pircbotx.hooks.types.GenericSnapshotEvent} (eg PartEvent,
		 * QuitEvent) since the entire UserChannelDao with all of its users and
		 * channels is cloned. This can optionally disabled by setting this to
		 * false, however this makes all
		 * {@link org.pircbotx.hooks.types.GenericSnapshotEvent#getUserChannelDaoSnapshot()}
		 * calls return null.
		 * <p>
		 * In regular usage disabling snapshots is not necessary because there
		 * relatively few user QUITs and PARTs per second.
		 */
		protected boolean snapshotsEnabled = true;
		//DCC
		/**
		 * If true sends filenames in quotes, otherwise uses underscores,
		 * default enabled.
		 */
		protected boolean dccFilenameQuotes = false;
		
		/**
		 * Ports to allow DCC incoming connections, recommended to set multiple
		 * as DCC connections will be rejected if no free port can be found
		 */
		protected List<Integer> dccPorts = Lists.newArrayList();
		
		/**
		 * The local address to bind DCC connections to, defaults to {@link #getLocalAddress()
		 * }
		 */
		protected InetAddress dccLocalAddress = null;
		
		/**
		 * Timeout for user to accept a sent DCC request, defaults to {@link #getSocketTimeout()
		 * }
		 */
		protected int dccAcceptTimeout = -1;
		
		/**
		 * Timeout for a user to accept a resumed DCC request, defaults to {@link #getDccResumeAcceptTimeout()
		 * }
		 */
		protected int dccResumeAcceptTimeout = -1;
		
		/**
		 * Size of the DCC file transfer buffer, default 1024 bytes
		 */
		protected int dccTransferBufferSize = 1024;
		
		/**
		 * Send DCC requests as passive/reverse requests if not specified
		 * otherwise, default false
		 */
		protected boolean dccPassiveRequest = false;
		//Connect information
		/**
		 * List of servers to connect to, easily add with the addServer methods
		 */
		protected List<ServerEntry> servers = Lists.newLinkedList();
		
		/**
		 * Password for IRC server, default null
		 */
		protected String serverPassword = null;
		
		/**
		 * Socket factory for connections, defaults to {@link SocketFactory#getDefault()
		 * }
		 */
		protected SocketFactory socketFactory = SocketFactory.getDefault();
		
		/**
		 * Address to bind to when connecting to IRC server, default null
		 */
		protected InetAddress localAddress = null;
		
		/**
		 * Charset encoding to use for connection, defaults to
		 * {@link Charset#defaultCharset()}
		 */
		protected Charset encoding = Charset.defaultCharset();
		
		/**
		 * Locale to use for connection, defaults to {@link Locale#getDefault()
		 * }
		 */
		protected Locale locale = Locale.getDefault();
		
		/**
		 * Milliseconds to wait with no data from the IRC server before sending
		 * a PING request to check if the socket is still alive, default 5
		 * minutes (1000x60x5=300,000 milliseconds)
		 */
		protected int socketTimeout = 1000 * 60 * 5;
		
		/**
		 * Maximum line length of IRC server, defaults 512 characters
		 */
		protected int maxLineLength = 512;
		
		/**
		 * Enable or disable automatic message splitting to fit
		 * {@link #getMaxLineLength()} to prevent the IRC server from possibly
		 * truncating or rejecting the line, default true.
		 */
		protected boolean autoSplitMessage = true;
		
		/**
		 * Enable or disable automatic nick changing if a nick is in use by
		 * adding a number to the end, default false which will throw a
		 * {@link IrcException} if the nick is already in use on the server
		 */
		protected boolean autoNickChange = false;
		
		/**
		 * Millisecond delay between sending messages, default 1000 milliseconds
		 */
		protected long messageDelay = 1000;
		
		/**
		 * Enable or disable creating a JVM shutdown hook which will properly
		 * QUIT the IRC server and shutdown the bot, default true
		 */
		protected boolean shutdownHookEnabled = true;
		
		/**
		 * Map of channels and keys to automatically join upon connecting.
		 */
		protected final Map<String, String> autoJoinChannels = Maps.newHashMap();
		
		/**
		 * Enable or disable use of an existing {@link IdentServer}, default
		 * false. Note that the IdentServer must be started separately or else
		 * an exception will be thrown
		 *
		 * @see IdentServer
		 */
		protected boolean identServerEnabled = false;
		
		/**
		 * Password to authenticate against NICKSERV, default null (will not try
		 * to identify)
		 */
		protected String nickservPassword = null;
		
		/**
		 * Case-insensitive message a user with 
		 * {@link #setNickservNick(java.lang.String) } in its hostmask will
		 * always contain when we have successfully identified, defaults to "you
		 * are now" which which matches all of the following known server
		 * responses:
		 * <ul>
		 * <li>ircd-seven (freenode) - You are now identified for PircBotX</li>
		 * <li>Unreal (swiftirc) - Password accepted - you are now
		 * recognized.</li>
		 * <li>InspIRCd (mozilla) - You are now logged in as PircBotX</li>
		 * </ul>
		 *
		 * @see PircBotX#isNickservIdentified()
		 * @see #setNickservNick(java.lang.String)
		 */
		protected String nickservOnSuccess = "you are now";
		
		/**
		 * The nick of the nickserv service account, default "nickserv".
		 *
		 * @see PircBotX#isNickservIdentified()
		 */
		protected String nickservNick = "nickserv";
		
		/**
		 * Delay joining channels until were identified to nickserv, default
		 * false
		 */
		protected boolean nickservDelayJoin = false;
		
		/**
		 * Enable or disable automatic reconnecting, default false. Note that
		 * you MUST call {@link PircBotX#stopBotReconnect() } when you do not
		 * want the bot to reconnect anymore!
		 */
		protected boolean autoReconnect = false;
		
		/**
		 * Delay in milliseconds between reconnect attempts, default 0.
		 */
		protected int autoReconnectDelay = 0;
		
		/**
		 * Number of times to attempt to reconnect, default 5.
		 */
		protected int autoReconnectAttempts = 5;
		//Bot classes
		//This is lazy loaded in {@link #getListenerManager()} since creating a thread pool is expensive
		/**
		 * The {@link ListenerManager} to use to handle events, default
		 * {@link ThreadedListenerManager}.
		 */
		protected ListenerManager listenerManager = null;
		
		/**
		 * Enable or disable CAP handling, defaults true.
		 */
		protected boolean capEnabled = true;
		
		/**
		 * IRCv3 CAP features to try to use, default enables multi-prefix and
		 * away-notify but ignoring if the server doesn't support them
		 */
		protected final List<CapHandler> capHandlers = Lists.<CapHandler>newArrayList(new EnableCapHandler("multi-prefix", true), new EnableCapHandler("away-notify", true));
		
		/**
		 * Handlers for channel modes, defaults to built-in handlers which cover
		 * basic modes that are generally supported on most IRC servers
		 */
		protected final List<ChannelModeHandler> channelModeHandlers = Lists.newArrayList(InputParser.DEFAULT_CHANNEL_MODE_HANDLERS);
		
		/**
		 * The {@link BotFactory} to use
		 */
		protected BotFactory botFactory = new BotFactory();

		/**
		 * Create with defaults that work in most situations and IRC servers
		 */
		public Builder() {
		}

		/**
		 * Copy values from an existing Configuration.
		 *
		 * @param configuration Configuration to copy values from
		 */
		public Builder(Configuration configuration) {
			this.webIrcEnabled = configuration.isWebIrcEnabled();
			this.webIrcUsername = configuration.getWebIrcUsername();
			this.webIrcHostname = configuration.getWebIrcHostname();
			this.webIrcAddress = configuration.getWebIrcAddress();
			this.webIrcPassword = configuration.getWebIrcPassword();
			this.name = configuration.getName();
			this.login = configuration.getLogin();
			this.version = configuration.getVersion();
			this.finger = configuration.getFinger();
			this.realName = configuration.getRealName();
			this.channelPrefixes = configuration.getChannelPrefixes();
			this.userLevelPrefixes = configuration.getUserLevelPrefixes();
			this.snapshotsEnabled = configuration.isSnapshotsEnabled();
			this.dccFilenameQuotes = configuration.isDccFilenameQuotes();
			this.dccPorts.clear();
			this.dccPorts.addAll(configuration.getDccPorts());
			this.dccLocalAddress = configuration.getDccLocalAddress();
			this.dccAcceptTimeout = configuration.getDccAcceptTimeout();
			this.dccResumeAcceptTimeout = configuration.getDccResumeAcceptTimeout();
			this.dccTransferBufferSize = configuration.getDccTransferBufferSize();
			this.dccPassiveRequest = configuration.isDccPassiveRequest();
			this.servers.clear();
			this.servers.addAll(configuration.getServers());
			this.serverPassword = configuration.getServerPassword();
			this.socketFactory = configuration.getSocketFactory();
			this.localAddress = configuration.getLocalAddress();
			this.encoding = configuration.getEncoding();
			this.locale = configuration.getLocale();
			this.socketTimeout = configuration.getSocketTimeout();
			this.maxLineLength = configuration.getMaxLineLength();
			this.autoSplitMessage = configuration.isAutoSplitMessage();
			this.autoNickChange = configuration.isAutoNickChange();
			this.messageDelay = configuration.getMessageDelay();
			this.listenerManager = configuration.getListenerManager();
			this.nickservPassword = configuration.getNickservPassword();
			this.nickservOnSuccess = configuration.getNickservOnSuccess();
			this.nickservNick = configuration.getNickservNick();
			this.nickservDelayJoin = configuration.isNickservDelayJoin();
			this.autoReconnect = configuration.isAutoReconnect();
			this.autoReconnectDelay = configuration.getAutoReconnectDelay();
			this.autoReconnectAttempts = configuration.getAutoReconnectAttempts();
			this.autoJoinChannels.clear();
			this.autoJoinChannels.putAll(configuration.getAutoJoinChannels());
			this.identServerEnabled = configuration.isIdentServerEnabled();
			this.capEnabled = configuration.isCapEnabled();
			this.capHandlers.clear();
			this.capHandlers.addAll(configuration.getCapHandlers());
			this.channelModeHandlers.clear();
			this.channelModeHandlers.addAll(configuration.getChannelModeHandlers().values());
			this.shutdownHookEnabled = configuration.isShutdownHookEnabled();
			this.botFactory = configuration.getBotFactory();
		}

		/**
		 * Copy values from another builder.
		 *
		 * @param otherBuilder
		 */
		public Builder(Builder otherBuilder) {
			this.webIrcEnabled = otherBuilder.isWebIrcEnabled();
			this.webIrcUsername = otherBuilder.getWebIrcUsername();
			this.webIrcHostname = otherBuilder.getWebIrcHostname();
			this.webIrcAddress = otherBuilder.getWebIrcAddress();
			this.webIrcPassword = otherBuilder.getWebIrcPassword();
			this.name = otherBuilder.getName();
			this.login = otherBuilder.getLogin();
			this.version = otherBuilder.getVersion();
			this.finger = otherBuilder.getFinger();
			this.realName = otherBuilder.getRealName();
			this.channelPrefixes = otherBuilder.getChannelPrefixes();
			this.userLevelPrefixes = otherBuilder.getUserLevelPrefixes();
			this.snapshotsEnabled = otherBuilder.isSnapshotsEnabled();
			this.dccFilenameQuotes = otherBuilder.isDccFilenameQuotes();
			this.dccPorts.clear();
			this.dccPorts.addAll(otherBuilder.getDccPorts());
			this.dccLocalAddress = otherBuilder.getDccLocalAddress();
			this.dccAcceptTimeout = otherBuilder.getDccAcceptTimeout();
			this.dccResumeAcceptTimeout = otherBuilder.getDccResumeAcceptTimeout();
			this.dccTransferBufferSize = otherBuilder.getDccTransferBufferSize();
			this.dccPassiveRequest = otherBuilder.isDccPassiveRequest();
			this.servers.clear();
			this.servers.addAll(otherBuilder.getServers());
			this.serverPassword = otherBuilder.getServerPassword();
			this.socketFactory = otherBuilder.getSocketFactory();
			this.localAddress = otherBuilder.getLocalAddress();
			this.encoding = otherBuilder.getEncoding();
			this.locale = otherBuilder.getLocale();
			this.socketTimeout = otherBuilder.getSocketTimeout();
			this.maxLineLength = otherBuilder.getMaxLineLength();
			this.autoSplitMessage = otherBuilder.isAutoSplitMessage();
			this.autoNickChange = otherBuilder.isAutoNickChange();
			this.messageDelay = otherBuilder.getMessageDelay();
			this.listenerManager = otherBuilder.getListenerManager();
			this.nickservPassword = otherBuilder.getNickservPassword();
			this.nickservOnSuccess = otherBuilder.getNickservOnSuccess();
			this.nickservNick = otherBuilder.getNickservNick();
			this.nickservDelayJoin = otherBuilder.isNickservDelayJoin();
			this.autoReconnect = otherBuilder.isAutoReconnect();
			this.autoReconnectDelay = otherBuilder.getAutoReconnectDelay();
			this.autoReconnectAttempts = otherBuilder.getAutoReconnectAttempts();
			this.autoJoinChannels.putAll(otherBuilder.getAutoJoinChannels());
			this.identServerEnabled = otherBuilder.isIdentServerEnabled();
			this.capEnabled = otherBuilder.isCapEnabled();
			this.capHandlers.clear();
			this.capHandlers.addAll(otherBuilder.getCapHandlers());
			this.channelModeHandlers.clear();
			this.channelModeHandlers.addAll(otherBuilder.getChannelModeHandlers());
			this.shutdownHookEnabled = otherBuilder.isShutdownHookEnabled();
			this.botFactory = otherBuilder.getBotFactory();
		}

		/**
		 * The local address to bind DCC connections to. Defaults to {@link #getLocalAddress()
		 * }
		 */
		public InetAddress getDccLocalAddress() {
			return (dccLocalAddress != null) ? dccLocalAddress : localAddress;
		}

		/**
		 * Timeout for user to accept a sent DCC request. Defaults to {@link #getSocketTimeout()
		 * }
		 */
		public int getDccAcceptTimeout() {
			return (dccAcceptTimeout != -1) ? dccAcceptTimeout : socketTimeout;
		}

		/**
		 * Timeout for a user to accept a resumed DCC request. Defaults to {@link #getDccResumeAcceptTimeout()
		 * }
		 */
		public int getDccResumeAcceptTimeout() {
			return (dccResumeAcceptTimeout != -1) ? dccResumeAcceptTimeout : getDccAcceptTimeout();
		}

		/**
		 * Add a collection of cap handlers
		 *
		 * @see #getCapHandlers()
		 * @param handlers
		 */
		public Builder addCapHandlers(@NonNull Iterable<CapHandler> handlers) {
			if (handlers == null) {
				throw new java.lang.NullPointerException("handlers");
			}
			for (CapHandler curHandler : handlers) {
				addCapHandler(curHandler);
			}
			return this;
		}

		/**
		 * Add a cap handler
		 *
		 * @see #getCapHandlers()
		 * @param handler
		 */
		public Builder addCapHandler(CapHandler handler) {
			getCapHandlers().add(handler);
			return this;
		}

		/**
		 * Add a collection of listeners to the current ListenerManager
		 *
		 * @see #getListenerManager()
		 * @param listeners
		 */
		public Builder addListeners(@NonNull Iterable<Listener> listeners) {
			if (listeners == null) {
				throw new java.lang.NullPointerException("listeners");
			}
			for (Listener curListener : listeners) {
				addListener(curListener);
			}
			return this;
		}

		/**
		 * Add a listener to the current ListenerManager
		 *
		 * @see #getListenerManager()
		 * @param listener
		 */
		public Builder addListener(Listener listener) {
			getListenerManager().addListener(listener);
			return this;
		}

		public Builder addAutoJoinChannels(@NonNull Iterable<String> channels) {
			if (channels == null) {
				throw new java.lang.NullPointerException("channels");
			}
			for (String curChannel : channels) {
				addAutoJoinChannel(curChannel);
			}
			return this;
		}

		/**
		 * Add a channel to join on connect
		 *
		 * @see #getAutoJoinChannels()
		 * @param channel
		 */
		public Builder addAutoJoinChannel(@NonNull String channel) {
			if (channel == null) {
				throw new java.lang.NullPointerException("channel");
			}
			if (StringUtils.isBlank(channel)) throw new RuntimeException("Channel must not be blank");
			getAutoJoinChannels().put(channel, "");
			return this;
		}

		/**
		 * Utility method for <code>{@link #getAutoJoinChannels()}.put(channel,
		 * key)</code>
		 *
		 * @param channel
		 */
		public Builder addAutoJoinChannel(@NonNull String channel, @NonNull String key) {
			if (channel == null) {
				throw new java.lang.NullPointerException("channel");
			}
			if (key == null) {
				throw new java.lang.NullPointerException("key");
			}
			if (StringUtils.isBlank(channel)) throw new RuntimeException("Channel must not be blank");
			if (StringUtils.isBlank(key)) throw new RuntimeException("Key must not be blank");
			getAutoJoinChannels().put(channel, key);
			return this;
		}

		public Builder addServer(@NonNull String server) {
			if (server == null) {
				throw new java.lang.NullPointerException("server");
			}
			servers.add(new ServerEntry(server, 6667));
			return this;
		}

		public Builder addServer(@NonNull String server, int port) {
			if (server == null) {
				throw new java.lang.NullPointerException("server");
			}
			servers.add(new ServerEntry(server, port));
			return this;
		}

		public Builder addServer(@NonNull ServerEntry serverEntry) {
			if (serverEntry == null) {
				throw new java.lang.NullPointerException("serverEntry");
			}
			servers.add(serverEntry);
			return this;
		}

		public Builder addServers(@NonNull Iterable<ServerEntry> serverEnteries) {
			if (serverEnteries == null) {
				throw new java.lang.NullPointerException("serverEnteries");
			}
			for (ServerEntry curServerEntry : serverEnteries) servers.add(curServerEntry);
			return this;
		}

		/**
		 * Sets a new ListenerManager. <b>NOTE:</b> The {@link CoreHooks} are
		 * added when this method is called. If you do not want this, remove
		 * CoreHooks with
		 * {@link ListenerManager#removeListener(org.pircbotx.hooks.Listener) }
		 *
		 * @param listenerManager The listener manager
		 */
		@SuppressWarnings("unchecked")
		public Builder setListenerManager(ListenerManager listenerManager) {
			this.listenerManager = listenerManager;
			for (Listener curListener : this.listenerManager.getListeners()) if (curListener instanceof CoreHooks) return this;
			listenerManager.addListener(new CoreHooks());
			return this;
		}

		public void replaceCoreHooksListener(CoreHooks extended) {
			//Find the corehooks impl
			CoreHooks orig = null;
			for (Listener curListener : this.listenerManager.getListeners()) if (curListener instanceof CoreHooks) orig = (CoreHooks)curListener;
			//Swap
			if (orig != null) this.listenerManager.removeListener(orig);
			addListener(extended);
		}

		/**
		 * Returns the current ListenerManager in use by this bot. Note that the
		 * default listener manager ({@link ListenerManager}) is lazy loaded
		 * here unless one was already set
		 *
		 * @return Current ListenerManager
		 */
		@SuppressWarnings("unchecked")
		public <M extends ListenerManager> M getListenerManager() {
			if (listenerManager == null) setListenerManager(new ThreadedListenerManager());
			return (M)listenerManager;
		}

		/**
		 * Builds a Configuration instance from the information in this builder
		 */
		public Configuration buildConfiguration() {
			return new Configuration(this);
		}

		/**
		 * Create a <i>new</i> builder with the specified hostname then build a
		 * configuration. Useful for template builders
		 *
		 * @param hostname
		 */
		public Configuration buildForServer(String hostname) {
			return new Builder(this).addServer(hostname).buildConfiguration();
		}

		/**
		 * Create a <i>new</i> builder with the specified hostname and port then
		 * build a configuration. Useful for template builders
		 *
		 * @param hostname
		 */
		public Configuration buildForServer(String hostname, int port) {
			return new Builder(this).addServer(hostname, port).buildConfiguration();
		}

		/**
		 * Create a <i>new</i> builder with the specified hostname, port, and
		 * password then build a configuration. Useful for template builders
		 *
		 * @param hostname
		 */
		public Configuration buildForServer(String hostname, int port, String password) {
			return new Builder(this).addServer(hostname, port).setServerPassword(password).buildConfiguration();
		}

		/**
		 * Enable or disable sending WEBIRC line on connect, default disabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isWebIrcEnabled() {
			return this.webIrcEnabled;
		}

		/**
		 * Username of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getWebIrcUsername() {
			return this.webIrcUsername;
		}

		/**
		 * Hostname of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getWebIrcHostname() {
			return this.webIrcHostname;
		}

		/**
		 * IP address of WEBIRC connection, must be set if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public InetAddress getWebIrcAddress() {
			return this.webIrcAddress;
		}

		/**
		 * Password of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getWebIrcPassword() {
			return this.webIrcPassword;
		}

		/**
		 * The nick to be used for the IRC connection (nick!login@host), must
		 * not be blank
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getName() {
			return this.name;
		}

		/**
		 * The login to be used for the IRC connection (nick!login@host),
		 * default PircBotX
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getLogin() {
			return this.login;
		}

		/**
		 * CTCP version response.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getVersion() {
			return this.version;
		}

		/**
		 * CTCP finger response
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getFinger() {
			return this.finger;
		}

		/**
		 * The realName/fullname used for WHOIS info, defaults to version
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getRealName() {
			return this.realName;
		}

		/**
		 * Allowed channel prefix characters, default <code>#&+!</code>
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getChannelPrefixes() {
			return this.channelPrefixes;
		}

		/**
		 * Supported channel prefixes that restrict a sent message to users with
		 * this mode, eg <code>PRIVMSG +#channel :hello</code> will only send a
		 * message to voiced or higher users, default <code>+@%&~!</code>
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getUserLevelPrefixes() {
			return this.userLevelPrefixes;
		}

		/**
		 * Enable creation of snapshots, default true. In bulk datasets or very
		 * lower power devices, creating snapshots can be a relatively expensive
		 * operation for every
		 * {@link org.pircbotx.hooks.types.GenericSnapshotEvent} (eg PartEvent,
		 * QuitEvent) since the entire UserChannelDao with all of its users and
		 * channels is cloned. This can optionally disabled by setting this to
		 * false, however this makes all
		 * {@link org.pircbotx.hooks.types.GenericSnapshotEvent#getUserChannelDaoSnapshot()}
		 * calls return null.
		 * <p>
		 * In regular usage disabling snapshots is not necessary because there
		 * relatively few user QUITs and PARTs per second.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isSnapshotsEnabled() {
			return this.snapshotsEnabled;
		}

		/**
		 * If true sends filenames in quotes, otherwise uses underscores,
		 * default enabled.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isDccFilenameQuotes() {
			return this.dccFilenameQuotes;
		}

		/**
		 * Ports to allow DCC incoming connections, recommended to set multiple
		 * as DCC connections will be rejected if no free port can be found
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public List<Integer> getDccPorts() {
			return this.dccPorts;
		}

		/**
		 * Size of the DCC file transfer buffer, default 1024 bytes
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int getDccTransferBufferSize() {
			return this.dccTransferBufferSize;
		}

		/**
		 * Send DCC requests as passive/reverse requests if not specified
		 * otherwise, default false
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isDccPassiveRequest() {
			return this.dccPassiveRequest;
		}

		/**
		 * List of servers to connect to, easily add with the addServer methods
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public List<ServerEntry> getServers() {
			return this.servers;
		}

		/**
		 * Password for IRC server, default null
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getServerPassword() {
			return this.serverPassword;
		}

		/**
		 * Socket factory for connections, defaults to {@link SocketFactory#getDefault()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public SocketFactory getSocketFactory() {
			return this.socketFactory;
		}

		/**
		 * Address to bind to when connecting to IRC server, default null
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public InetAddress getLocalAddress() {
			return this.localAddress;
		}

		/**
		 * Charset encoding to use for connection, defaults to
		 * {@link Charset#defaultCharset()}
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Charset getEncoding() {
			return this.encoding;
		}

		/**
		 * Locale to use for connection, defaults to {@link Locale#getDefault()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Locale getLocale() {
			return this.locale;
		}

		/**
		 * Milliseconds to wait with no data from the IRC server before sending
		 * a PING request to check if the socket is still alive, default 5
		 * minutes (1000x60x5=300,000 milliseconds)
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int getSocketTimeout() {
			return this.socketTimeout;
		}

		/**
		 * Maximum line length of IRC server, defaults 512 characters
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int getMaxLineLength() {
			return this.maxLineLength;
		}

		/**
		 * Enable or disable automatic message splitting to fit
		 * {@link #getMaxLineLength()} to prevent the IRC server from possibly
		 * truncating or rejecting the line, default true.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isAutoSplitMessage() {
			return this.autoSplitMessage;
		}

		/**
		 * Enable or disable automatic nick changing if a nick is in use by
		 * adding a number to the end, default false which will throw a
		 * {@link IrcException} if the nick is already in use on the server
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isAutoNickChange() {
			return this.autoNickChange;
		}

		/**
		 * Millisecond delay between sending messages, default 1000 milliseconds
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public long getMessageDelay() {
			return this.messageDelay;
		}

		/**
		 * Enable or disable creating a JVM shutdown hook which will properly
		 * QUIT the IRC server and shutdown the bot, default true
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isShutdownHookEnabled() {
			return this.shutdownHookEnabled;
		}

		/**
		 * Map of channels and keys to automatically join upon connecting.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Map<String, String> getAutoJoinChannels() {
			return this.autoJoinChannels;
		}

		/**
		 * Enable or disable use of an existing {@link IdentServer}, default
		 * false. Note that the IdentServer must be started separately or else
		 * an exception will be thrown
		 *
		 * @see IdentServer
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isIdentServerEnabled() {
			return this.identServerEnabled;
		}

		/**
		 * Password to authenticate against NICKSERV, default null (will not try
		 * to identify)
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getNickservPassword() {
			return this.nickservPassword;
		}

		/**
		 * Case-insensitive message a user with 
		 * {@link #setNickservNick(java.lang.String) } in its hostmask will
		 * always contain when we have successfully identified, defaults to "you
		 * are now" which which matches all of the following known server
		 * responses:
		 * <ul>
		 * <li>ircd-seven (freenode) - You are now identified for PircBotX</li>
		 * <li>Unreal (swiftirc) - Password accepted - you are now
		 * recognized.</li>
		 * <li>InspIRCd (mozilla) - You are now logged in as PircBotX</li>
		 * </ul>
		 *
		 * @see PircBotX#isNickservIdentified()
		 * @see #setNickservNick(java.lang.String)
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getNickservOnSuccess() {
			return this.nickservOnSuccess;
		}

		/**
		 * The nick of the nickserv service account, default "nickserv".
		 *
		 * @see PircBotX#isNickservIdentified()
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getNickservNick() {
			return this.nickservNick;
		}

		/**
		 * Delay joining channels until were identified to nickserv, default
		 * false
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isNickservDelayJoin() {
			return this.nickservDelayJoin;
		}

		/**
		 * Enable or disable automatic reconnecting, default false. Note that
		 * you MUST call {@link PircBotX#stopBotReconnect() } when you do not
		 * want the bot to reconnect anymore!
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isAutoReconnect() {
			return this.autoReconnect;
		}

		/**
		 * Delay in milliseconds between reconnect attempts, default 0.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int getAutoReconnectDelay() {
			return this.autoReconnectDelay;
		}

		/**
		 * Number of times to attempt to reconnect, default 5.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int getAutoReconnectAttempts() {
			return this.autoReconnectAttempts;
		}

		/**
		 * Enable or disable CAP handling, defaults true.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean isCapEnabled() {
			return this.capEnabled;
		}

		/**
		 * IRCv3 CAP features to try to use, default enables multi-prefix and
		 * away-notify but ignoring if the server doesn't support them
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public List<CapHandler> getCapHandlers() {
			return this.capHandlers;
		}

		/**
		 * Handlers for channel modes, defaults to built-in handlers which cover
		 * basic modes that are generally supported on most IRC servers
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public List<ChannelModeHandler> getChannelModeHandlers() {
			return this.channelModeHandlers;
		}

		/**
		 * The {@link BotFactory} to use
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public BotFactory getBotFactory() {
			return this.botFactory;
		}

		/**
		 * Enable or disable sending WEBIRC line on connect, default disabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setWebIrcEnabled(final boolean webIrcEnabled) {
			this.webIrcEnabled = webIrcEnabled;
			return this;
		}

		/**
		 * Username of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setWebIrcUsername(final String webIrcUsername) {
			this.webIrcUsername = webIrcUsername;
			return this;
		}

		/**
		 * Hostname of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setWebIrcHostname(final String webIrcHostname) {
			this.webIrcHostname = webIrcHostname;
			return this;
		}

		/**
		 * IP address of WEBIRC connection, must be set if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setWebIrcAddress(final InetAddress webIrcAddress) {
			this.webIrcAddress = webIrcAddress;
			return this;
		}

		/**
		 * Password of WEBIRC connection, must not be blank if WEBIRC is enabled
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setWebIrcPassword(final String webIrcPassword) {
			this.webIrcPassword = webIrcPassword;
			return this;
		}

		/**
		 * The nick to be used for the IRC connection (nick!login@host), must
		 * not be blank
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setName(final String name) {
			this.name = name;
			return this;
		}

		/**
		 * The login to be used for the IRC connection (nick!login@host),
		 * default PircBotX
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setLogin(final String login) {
			this.login = login;
			return this;
		}

		/**
		 * CTCP version response.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setVersion(final String version) {
			this.version = version;
			return this;
		}

		/**
		 * CTCP finger response
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setFinger(final String finger) {
			this.finger = finger;
			return this;
		}

		/**
		 * The realName/fullname used for WHOIS info, defaults to version
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setRealName(final String realName) {
			this.realName = realName;
			return this;
		}

		/**
		 * Allowed channel prefix characters, default <code>#&+!</code>
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setChannelPrefixes(final String channelPrefixes) {
			this.channelPrefixes = channelPrefixes;
			return this;
		}

		/**
		 * Supported channel prefixes that restrict a sent message to users with
		 * this mode, eg <code>PRIVMSG +#channel :hello</code> will only send a
		 * message to voiced or higher users, default <code>+@%&~!</code>
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setUserLevelPrefixes(final String userLevelPrefixes) {
			this.userLevelPrefixes = userLevelPrefixes;
			return this;
		}

		/**
		 * Enable creation of snapshots, default true. In bulk datasets or very
		 * lower power devices, creating snapshots can be a relatively expensive
		 * operation for every
		 * {@link org.pircbotx.hooks.types.GenericSnapshotEvent} (eg PartEvent,
		 * QuitEvent) since the entire UserChannelDao with all of its users and
		 * channels is cloned. This can optionally disabled by setting this to
		 * false, however this makes all
		 * {@link org.pircbotx.hooks.types.GenericSnapshotEvent#getUserChannelDaoSnapshot()}
		 * calls return null.
		 * <p>
		 * In regular usage disabling snapshots is not necessary because there
		 * relatively few user QUITs and PARTs per second.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setSnapshotsEnabled(final boolean snapshotsEnabled) {
			this.snapshotsEnabled = snapshotsEnabled;
			return this;
		}

		/**
		 * If true sends filenames in quotes, otherwise uses underscores,
		 * default enabled.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccFilenameQuotes(final boolean dccFilenameQuotes) {
			this.dccFilenameQuotes = dccFilenameQuotes;
			return this;
		}

		/**
		 * Ports to allow DCC incoming connections, recommended to set multiple
		 * as DCC connections will be rejected if no free port can be found
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccPorts(final List<Integer> dccPorts) {
			this.dccPorts = dccPorts;
			return this;
		}

		/**
		 * The local address to bind DCC connections to, defaults to {@link #getLocalAddress()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccLocalAddress(final InetAddress dccLocalAddress) {
			this.dccLocalAddress = dccLocalAddress;
			return this;
		}

		/**
		 * Timeout for user to accept a sent DCC request, defaults to {@link #getSocketTimeout()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccAcceptTimeout(final int dccAcceptTimeout) {
			this.dccAcceptTimeout = dccAcceptTimeout;
			return this;
		}

		/**
		 * Timeout for a user to accept a resumed DCC request, defaults to {@link #getDccResumeAcceptTimeout()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccResumeAcceptTimeout(final int dccResumeAcceptTimeout) {
			this.dccResumeAcceptTimeout = dccResumeAcceptTimeout;
			return this;
		}

		/**
		 * Size of the DCC file transfer buffer, default 1024 bytes
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccTransferBufferSize(final int dccTransferBufferSize) {
			this.dccTransferBufferSize = dccTransferBufferSize;
			return this;
		}

		/**
		 * Send DCC requests as passive/reverse requests if not specified
		 * otherwise, default false
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setDccPassiveRequest(final boolean dccPassiveRequest) {
			this.dccPassiveRequest = dccPassiveRequest;
			return this;
		}

		/**
		 * List of servers to connect to, easily add with the addServer methods
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setServers(final List<ServerEntry> servers) {
			this.servers = servers;
			return this;
		}

		/**
		 * Password for IRC server, default null
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setServerPassword(final String serverPassword) {
			this.serverPassword = serverPassword;
			return this;
		}

		/**
		 * Socket factory for connections, defaults to {@link SocketFactory#getDefault()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setSocketFactory(final SocketFactory socketFactory) {
			this.socketFactory = socketFactory;
			return this;
		}

		/**
		 * Address to bind to when connecting to IRC server, default null
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setLocalAddress(final InetAddress localAddress) {
			this.localAddress = localAddress;
			return this;
		}

		/**
		 * Charset encoding to use for connection, defaults to
		 * {@link Charset#defaultCharset()}
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setEncoding(final Charset encoding) {
			this.encoding = encoding;
			return this;
		}

		/**
		 * Locale to use for connection, defaults to {@link Locale#getDefault()
		 * }
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setLocale(final Locale locale) {
			this.locale = locale;
			return this;
		}

		/**
		 * Milliseconds to wait with no data from the IRC server before sending
		 * a PING request to check if the socket is still alive, default 5
		 * minutes (1000x60x5=300,000 milliseconds)
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setSocketTimeout(final int socketTimeout) {
			this.socketTimeout = socketTimeout;
			return this;
		}

		/**
		 * Maximum line length of IRC server, defaults 512 characters
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setMaxLineLength(final int maxLineLength) {
			this.maxLineLength = maxLineLength;
			return this;
		}

		/**
		 * Enable or disable automatic message splitting to fit
		 * {@link #getMaxLineLength()} to prevent the IRC server from possibly
		 * truncating or rejecting the line, default true.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setAutoSplitMessage(final boolean autoSplitMessage) {
			this.autoSplitMessage = autoSplitMessage;
			return this;
		}

		/**
		 * Enable or disable automatic nick changing if a nick is in use by
		 * adding a number to the end, default false which will throw a
		 * {@link IrcException} if the nick is already in use on the server
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setAutoNickChange(final boolean autoNickChange) {
			this.autoNickChange = autoNickChange;
			return this;
		}

		/**
		 * Millisecond delay between sending messages, default 1000 milliseconds
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setMessageDelay(final long messageDelay) {
			this.messageDelay = messageDelay;
			return this;
		}

		/**
		 * Enable or disable creating a JVM shutdown hook which will properly
		 * QUIT the IRC server and shutdown the bot, default true
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setShutdownHookEnabled(final boolean shutdownHookEnabled) {
			this.shutdownHookEnabled = shutdownHookEnabled;
			return this;
		}

		/**
		 * Enable or disable use of an existing {@link IdentServer}, default
		 * false. Note that the IdentServer must be started separately or else
		 * an exception will be thrown
		 *
		 * @see IdentServer
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setIdentServerEnabled(final boolean identServerEnabled) {
			this.identServerEnabled = identServerEnabled;
			return this;
		}

		/**
		 * Password to authenticate against NICKSERV, default null (will not try
		 * to identify)
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setNickservPassword(final String nickservPassword) {
			this.nickservPassword = nickservPassword;
			return this;
		}

		/**
		 * Case-insensitive message a user with 
		 * {@link #setNickservNick(java.lang.String) } in its hostmask will
		 * always contain when we have successfully identified, defaults to "you
		 * are now" which which matches all of the following known server
		 * responses:
		 * <ul>
		 * <li>ircd-seven (freenode) - You are now identified for PircBotX</li>
		 * <li>Unreal (swiftirc) - Password accepted - you are now
		 * recognized.</li>
		 * <li>InspIRCd (mozilla) - You are now logged in as PircBotX</li>
		 * </ul>
		 *
		 * @see PircBotX#isNickservIdentified()
		 * @see #setNickservNick(java.lang.String)
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setNickservOnSuccess(final String nickservOnSuccess) {
			this.nickservOnSuccess = nickservOnSuccess;
			return this;
		}

		/**
		 * The nick of the nickserv service account, default "nickserv".
		 *
		 * @see PircBotX#isNickservIdentified()
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setNickservNick(final String nickservNick) {
			this.nickservNick = nickservNick;
			return this;
		}

		/**
		 * Delay joining channels until were identified to nickserv, default
		 * false
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setNickservDelayJoin(final boolean nickservDelayJoin) {
			this.nickservDelayJoin = nickservDelayJoin;
			return this;
		}

		/**
		 * Enable or disable automatic reconnecting, default false. Note that
		 * you MUST call {@link PircBotX#stopBotReconnect() } when you do not
		 * want the bot to reconnect anymore!
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setAutoReconnect(final boolean autoReconnect) {
			this.autoReconnect = autoReconnect;
			return this;
		}

		/**
		 * Delay in milliseconds between reconnect attempts, default 0.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setAutoReconnectDelay(final int autoReconnectDelay) {
			this.autoReconnectDelay = autoReconnectDelay;
			return this;
		}

		/**
		 * Number of times to attempt to reconnect, default 5.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setAutoReconnectAttempts(final int autoReconnectAttempts) {
			this.autoReconnectAttempts = autoReconnectAttempts;
			return this;
		}

		/**
		 * Enable or disable CAP handling, defaults true.
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setCapEnabled(final boolean capEnabled) {
			this.capEnabled = capEnabled;
			return this;
		}

		/**
		 * The {@link BotFactory} to use
		 */
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public Builder setBotFactory(final BotFactory botFactory) {
			this.botFactory = botFactory;
			return this;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean equals(final java.lang.Object o) {
			if (o == this) return true;
			if (!(o instanceof Configuration.Builder)) return false;
			final Builder other = (Builder)o;
			if (!other.canEqual((java.lang.Object)this)) return false;
			if (this.isWebIrcEnabled() != other.isWebIrcEnabled()) return false;
			final java.lang.Object this$webIrcUsername = this.getWebIrcUsername();
			final java.lang.Object other$webIrcUsername = other.getWebIrcUsername();
			if (this$webIrcUsername == null ? other$webIrcUsername != null : !this$webIrcUsername.equals(other$webIrcUsername)) return false;
			final java.lang.Object this$webIrcHostname = this.getWebIrcHostname();
			final java.lang.Object other$webIrcHostname = other.getWebIrcHostname();
			if (this$webIrcHostname == null ? other$webIrcHostname != null : !this$webIrcHostname.equals(other$webIrcHostname)) return false;
			final java.lang.Object this$webIrcAddress = this.getWebIrcAddress();
			final java.lang.Object other$webIrcAddress = other.getWebIrcAddress();
			if (this$webIrcAddress == null ? other$webIrcAddress != null : !this$webIrcAddress.equals(other$webIrcAddress)) return false;
			final java.lang.Object this$webIrcPassword = this.getWebIrcPassword();
			final java.lang.Object other$webIrcPassword = other.getWebIrcPassword();
			if (this$webIrcPassword == null ? other$webIrcPassword != null : !this$webIrcPassword.equals(other$webIrcPassword)) return false;
			final java.lang.Object this$name = this.getName();
			final java.lang.Object other$name = other.getName();
			if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;
			final java.lang.Object this$login = this.getLogin();
			final java.lang.Object other$login = other.getLogin();
			if (this$login == null ? other$login != null : !this$login.equals(other$login)) return false;
			final java.lang.Object this$version = this.getVersion();
			final java.lang.Object other$version = other.getVersion();
			if (this$version == null ? other$version != null : !this$version.equals(other$version)) return false;
			final java.lang.Object this$finger = this.getFinger();
			final java.lang.Object other$finger = other.getFinger();
			if (this$finger == null ? other$finger != null : !this$finger.equals(other$finger)) return false;
			final java.lang.Object this$realName = this.getRealName();
			final java.lang.Object other$realName = other.getRealName();
			if (this$realName == null ? other$realName != null : !this$realName.equals(other$realName)) return false;
			final java.lang.Object this$channelPrefixes = this.getChannelPrefixes();
			final java.lang.Object other$channelPrefixes = other.getChannelPrefixes();
			if (this$channelPrefixes == null ? other$channelPrefixes != null : !this$channelPrefixes.equals(other$channelPrefixes)) return false;
			final java.lang.Object this$userLevelPrefixes = this.getUserLevelPrefixes();
			final java.lang.Object other$userLevelPrefixes = other.getUserLevelPrefixes();
			if (this$userLevelPrefixes == null ? other$userLevelPrefixes != null : !this$userLevelPrefixes.equals(other$userLevelPrefixes)) return false;
			if (this.isSnapshotsEnabled() != other.isSnapshotsEnabled()) return false;
			if (this.isDccFilenameQuotes() != other.isDccFilenameQuotes()) return false;
			final java.lang.Object this$dccPorts = this.getDccPorts();
			final java.lang.Object other$dccPorts = other.getDccPorts();
			if (this$dccPorts == null ? other$dccPorts != null : !this$dccPorts.equals(other$dccPorts)) return false;
			final java.lang.Object this$dccLocalAddress = this.getDccLocalAddress();
			final java.lang.Object other$dccLocalAddress = other.getDccLocalAddress();
			if (this$dccLocalAddress == null ? other$dccLocalAddress != null : !this$dccLocalAddress.equals(other$dccLocalAddress)) return false;
			if (this.getDccAcceptTimeout() != other.getDccAcceptTimeout()) return false;
			if (this.getDccResumeAcceptTimeout() != other.getDccResumeAcceptTimeout()) return false;
			if (this.getDccTransferBufferSize() != other.getDccTransferBufferSize()) return false;
			if (this.isDccPassiveRequest() != other.isDccPassiveRequest()) return false;
			final java.lang.Object this$servers = this.getServers();
			final java.lang.Object other$servers = other.getServers();
			if (this$servers == null ? other$servers != null : !this$servers.equals(other$servers)) return false;
			final java.lang.Object this$serverPassword = this.getServerPassword();
			final java.lang.Object other$serverPassword = other.getServerPassword();
			if (this$serverPassword == null ? other$serverPassword != null : !this$serverPassword.equals(other$serverPassword)) return false;
			final java.lang.Object this$socketFactory = this.getSocketFactory();
			final java.lang.Object other$socketFactory = other.getSocketFactory();
			if (this$socketFactory == null ? other$socketFactory != null : !this$socketFactory.equals(other$socketFactory)) return false;
			final java.lang.Object this$localAddress = this.getLocalAddress();
			final java.lang.Object other$localAddress = other.getLocalAddress();
			if (this$localAddress == null ? other$localAddress != null : !this$localAddress.equals(other$localAddress)) return false;
			final java.lang.Object this$encoding = this.getEncoding();
			final java.lang.Object other$encoding = other.getEncoding();
			if (this$encoding == null ? other$encoding != null : !this$encoding.equals(other$encoding)) return false;
			final java.lang.Object this$locale = this.getLocale();
			final java.lang.Object other$locale = other.getLocale();
			if (this$locale == null ? other$locale != null : !this$locale.equals(other$locale)) return false;
			if (this.getSocketTimeout() != other.getSocketTimeout()) return false;
			if (this.getMaxLineLength() != other.getMaxLineLength()) return false;
			if (this.isAutoSplitMessage() != other.isAutoSplitMessage()) return false;
			if (this.isAutoNickChange() != other.isAutoNickChange()) return false;
			if (this.getMessageDelay() != other.getMessageDelay()) return false;
			if (this.isShutdownHookEnabled() != other.isShutdownHookEnabled()) return false;
			final java.lang.Object this$autoJoinChannels = this.getAutoJoinChannels();
			final java.lang.Object other$autoJoinChannels = other.getAutoJoinChannels();
			if (this$autoJoinChannels == null ? other$autoJoinChannels != null : !this$autoJoinChannels.equals(other$autoJoinChannels)) return false;
			if (this.isIdentServerEnabled() != other.isIdentServerEnabled()) return false;
			final java.lang.Object this$nickservPassword = this.getNickservPassword();
			final java.lang.Object other$nickservPassword = other.getNickservPassword();
			if (this$nickservPassword == null ? other$nickservPassword != null : !this$nickservPassword.equals(other$nickservPassword)) return false;
			final java.lang.Object this$nickservOnSuccess = this.getNickservOnSuccess();
			final java.lang.Object other$nickservOnSuccess = other.getNickservOnSuccess();
			if (this$nickservOnSuccess == null ? other$nickservOnSuccess != null : !this$nickservOnSuccess.equals(other$nickservOnSuccess)) return false;
			final java.lang.Object this$nickservNick = this.getNickservNick();
			final java.lang.Object other$nickservNick = other.getNickservNick();
			if (this$nickservNick == null ? other$nickservNick != null : !this$nickservNick.equals(other$nickservNick)) return false;
			if (this.isNickservDelayJoin() != other.isNickservDelayJoin()) return false;
			if (this.isAutoReconnect() != other.isAutoReconnect()) return false;
			if (this.getAutoReconnectDelay() != other.getAutoReconnectDelay()) return false;
			if (this.getAutoReconnectAttempts() != other.getAutoReconnectAttempts()) return false;
			final java.lang.Object this$listenerManager = this.getListenerManager();
			final java.lang.Object other$listenerManager = other.getListenerManager();
			if (this$listenerManager == null ? other$listenerManager != null : !this$listenerManager.equals(other$listenerManager)) return false;
			if (this.isCapEnabled() != other.isCapEnabled()) return false;
			final java.lang.Object this$capHandlers = this.getCapHandlers();
			final java.lang.Object other$capHandlers = other.getCapHandlers();
			if (this$capHandlers == null ? other$capHandlers != null : !this$capHandlers.equals(other$capHandlers)) return false;
			final java.lang.Object this$channelModeHandlers = this.getChannelModeHandlers();
			final java.lang.Object other$channelModeHandlers = other.getChannelModeHandlers();
			if (this$channelModeHandlers == null ? other$channelModeHandlers != null : !this$channelModeHandlers.equals(other$channelModeHandlers)) return false;
			final java.lang.Object this$botFactory = this.getBotFactory();
			final java.lang.Object other$botFactory = other.getBotFactory();
			if (this$botFactory == null ? other$botFactory != null : !this$botFactory.equals(other$botFactory)) return false;
			return true;
		}

		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		protected boolean canEqual(final java.lang.Object other) {
			return other instanceof Configuration.Builder;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int hashCode() {
			final int PRIME = 59;
			int result = 1;
			result = result * PRIME + (this.isWebIrcEnabled() ? 79 : 97);
			final java.lang.Object $webIrcUsername = this.getWebIrcUsername();
			result = result * PRIME + ($webIrcUsername == null ? 0 : $webIrcUsername.hashCode());
			final java.lang.Object $webIrcHostname = this.getWebIrcHostname();
			result = result * PRIME + ($webIrcHostname == null ? 0 : $webIrcHostname.hashCode());
			final java.lang.Object $webIrcAddress = this.getWebIrcAddress();
			result = result * PRIME + ($webIrcAddress == null ? 0 : $webIrcAddress.hashCode());
			final java.lang.Object $webIrcPassword = this.getWebIrcPassword();
			result = result * PRIME + ($webIrcPassword == null ? 0 : $webIrcPassword.hashCode());
			final java.lang.Object $name = this.getName();
			result = result * PRIME + ($name == null ? 0 : $name.hashCode());
			final java.lang.Object $login = this.getLogin();
			result = result * PRIME + ($login == null ? 0 : $login.hashCode());
			final java.lang.Object $version = this.getVersion();
			result = result * PRIME + ($version == null ? 0 : $version.hashCode());
			final java.lang.Object $finger = this.getFinger();
			result = result * PRIME + ($finger == null ? 0 : $finger.hashCode());
			final java.lang.Object $realName = this.getRealName();
			result = result * PRIME + ($realName == null ? 0 : $realName.hashCode());
			final java.lang.Object $channelPrefixes = this.getChannelPrefixes();
			result = result * PRIME + ($channelPrefixes == null ? 0 : $channelPrefixes.hashCode());
			final java.lang.Object $userLevelPrefixes = this.getUserLevelPrefixes();
			result = result * PRIME + ($userLevelPrefixes == null ? 0 : $userLevelPrefixes.hashCode());
			result = result * PRIME + (this.isSnapshotsEnabled() ? 79 : 97);
			result = result * PRIME + (this.isDccFilenameQuotes() ? 79 : 97);
			final java.lang.Object $dccPorts = this.getDccPorts();
			result = result * PRIME + ($dccPorts == null ? 0 : $dccPorts.hashCode());
			final java.lang.Object $dccLocalAddress = this.getDccLocalAddress();
			result = result * PRIME + ($dccLocalAddress == null ? 0 : $dccLocalAddress.hashCode());
			result = result * PRIME + this.getDccAcceptTimeout();
			result = result * PRIME + this.getDccResumeAcceptTimeout();
			result = result * PRIME + this.getDccTransferBufferSize();
			result = result * PRIME + (this.isDccPassiveRequest() ? 79 : 97);
			final java.lang.Object $servers = this.getServers();
			result = result * PRIME + ($servers == null ? 0 : $servers.hashCode());
			final java.lang.Object $serverPassword = this.getServerPassword();
			result = result * PRIME + ($serverPassword == null ? 0 : $serverPassword.hashCode());
			final java.lang.Object $socketFactory = this.getSocketFactory();
			result = result * PRIME + ($socketFactory == null ? 0 : $socketFactory.hashCode());
			final java.lang.Object $localAddress = this.getLocalAddress();
			result = result * PRIME + ($localAddress == null ? 0 : $localAddress.hashCode());
			final java.lang.Object $encoding = this.getEncoding();
			result = result * PRIME + ($encoding == null ? 0 : $encoding.hashCode());
			final java.lang.Object $locale = this.getLocale();
			result = result * PRIME + ($locale == null ? 0 : $locale.hashCode());
			result = result * PRIME + this.getSocketTimeout();
			result = result * PRIME + this.getMaxLineLength();
			result = result * PRIME + (this.isAutoSplitMessage() ? 79 : 97);
			result = result * PRIME + (this.isAutoNickChange() ? 79 : 97);
			final long $messageDelay = this.getMessageDelay();
			result = result * PRIME + (int)($messageDelay >>> 32 ^ $messageDelay);
			result = result * PRIME + (this.isShutdownHookEnabled() ? 79 : 97);
			final java.lang.Object $autoJoinChannels = this.getAutoJoinChannels();
			result = result * PRIME + ($autoJoinChannels == null ? 0 : $autoJoinChannels.hashCode());
			result = result * PRIME + (this.isIdentServerEnabled() ? 79 : 97);
			final java.lang.Object $nickservPassword = this.getNickservPassword();
			result = result * PRIME + ($nickservPassword == null ? 0 : $nickservPassword.hashCode());
			final java.lang.Object $nickservOnSuccess = this.getNickservOnSuccess();
			result = result * PRIME + ($nickservOnSuccess == null ? 0 : $nickservOnSuccess.hashCode());
			final java.lang.Object $nickservNick = this.getNickservNick();
			result = result * PRIME + ($nickservNick == null ? 0 : $nickservNick.hashCode());
			result = result * PRIME + (this.isNickservDelayJoin() ? 79 : 97);
			result = result * PRIME + (this.isAutoReconnect() ? 79 : 97);
			result = result * PRIME + this.getAutoReconnectDelay();
			result = result * PRIME + this.getAutoReconnectAttempts();
			final java.lang.Object $listenerManager = this.getListenerManager();
			result = result * PRIME + ($listenerManager == null ? 0 : $listenerManager.hashCode());
			result = result * PRIME + (this.isCapEnabled() ? 79 : 97);
			final java.lang.Object $capHandlers = this.getCapHandlers();
			result = result * PRIME + ($capHandlers == null ? 0 : $capHandlers.hashCode());
			final java.lang.Object $channelModeHandlers = this.getChannelModeHandlers();
			result = result * PRIME + ($channelModeHandlers == null ? 0 : $channelModeHandlers.hashCode());
			final java.lang.Object $botFactory = this.getBotFactory();
			result = result * PRIME + ($botFactory == null ? 0 : $botFactory.hashCode());
			return result;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public java.lang.String toString() {
			return "Configuration.Builder(webIrcEnabled=" + this.isWebIrcEnabled() + ", webIrcUsername=" + this.getWebIrcUsername() + ", webIrcHostname=" + this.getWebIrcHostname() + ", webIrcAddress=" + this.getWebIrcAddress() + ", webIrcPassword=" + this.getWebIrcPassword() + ", name=" + this.getName() + ", login=" + this.getLogin() + ", version=" + this.getVersion() + ", finger=" + this.getFinger() + ", realName=" + this.getRealName() + ", channelPrefixes=" + this.getChannelPrefixes() + ", userLevelPrefixes=" + this.getUserLevelPrefixes() + ", snapshotsEnabled=" + this.isSnapshotsEnabled() + ", dccFilenameQuotes=" + this.isDccFilenameQuotes() + ", dccPorts=" + this.getDccPorts() + ", dccLocalAddress=" + this.getDccLocalAddress() + ", dccAcceptTimeout=" + this.getDccAcceptTimeout() + ", dccResumeAcceptTimeout=" + this.getDccResumeAcceptTimeout() + ", dccTransferBufferSize=" + this.getDccTransferBufferSize() + ", dccPassiveRequest=" + this.isDccPassiveRequest() + ", servers=" + this.getServers() + ", serverPassword=" + this.getServerPassword() + ", socketFactory=" + this.getSocketFactory() + ", localAddress=" + this.getLocalAddress() + ", encoding=" + this.getEncoding() + ", locale=" + this.getLocale() + ", socketTimeout=" + this.getSocketTimeout() + ", maxLineLength=" + this.getMaxLineLength() + ", autoSplitMessage=" + this.isAutoSplitMessage() + ", autoNickChange=" + this.isAutoNickChange() + ", messageDelay=" + this.getMessageDelay() + ", shutdownHookEnabled=" + this.isShutdownHookEnabled() + ", autoJoinChannels=" + this.getAutoJoinChannels() + ", identServerEnabled=" + this.isIdentServerEnabled() + ", nickservPassword=" + this.getNickservPassword() + ", nickservOnSuccess=" + this.getNickservOnSuccess() + ", nickservNick=" + this.getNickservNick() + ", nickservDelayJoin=" + this.isNickservDelayJoin() + ", autoReconnect=" + this.isAutoReconnect() + ", autoReconnectDelay=" + this.getAutoReconnectDelay() + ", autoReconnectAttempts=" + this.getAutoReconnectAttempts() + ", listenerManager=" + this.getListenerManager() + ", capEnabled=" + this.isCapEnabled() + ", capHandlers=" + this.getCapHandlers() + ", channelModeHandlers=" + this.getChannelModeHandlers() + ", botFactory=" + this.getBotFactory() + ")";
		}
	}

	/**
	 * Factory for various internal bot classes.
	 */
	public static class BotFactory {


		public UserChannelDao createUserChannelDao(PircBotX bot) {
			return new UserChannelDao(bot, bot.getConfiguration().getBotFactory());
		}

		public OutputRaw createOutputRaw(PircBotX bot) {
			return new OutputRaw(bot);
		}

		public OutputCAP createOutputCAP(PircBotX bot) {
			return new OutputCAP(bot);
		}

		public OutputIRC createOutputIRC(PircBotX bot) {
			return new OutputIRC(bot);
		}

		public OutputDCC createOutputDCC(PircBotX bot) {
			return new OutputDCC(bot);
		}

		public OutputChannel createOutputChannel(PircBotX bot, Channel channel) {
			return new OutputChannel(bot, channel);
		}

		public OutputUser createOutputUser(PircBotX bot, UserHostmask user) {
			return new OutputUser(bot, user);
		}

		public InputParser createInputParser(PircBotX bot) {
			return new InputParser(bot);
		}

		public DccHandler createDccHandler(PircBotX bot) {
			return new DccHandler(bot);
		}

		public SendChat createSendChat(PircBotX bot, User user, Socket socket) throws IOException {
			return new SendChat(user, socket, bot.getConfiguration().getEncoding());
		}

		public ReceiveChat createReceiveChat(PircBotX bot, User user, Socket socket) throws IOException {
			return new ReceiveChat(user, socket, bot.getConfiguration().getEncoding());
		}

		public SendFileTransfer createSendFileTransfer(PircBotX bot, Socket socket, User user, File file, long startPosition) {
			return new SendFileTransfer(bot.getConfiguration(), socket, user, file, startPosition);
		}

		public ReceiveFileTransfer createReceiveFileTransfer(PircBotX bot, Socket socket, User user, File file, long startPosition, long fileSize) {
			return new ReceiveFileTransfer(bot.getConfiguration(), socket, user, file, startPosition, fileSize);
		}

		public ServerInfo createServerInfo(PircBotX bot) {
			return new ServerInfo(bot);
		}

		public UserHostmask createUserHostmask(PircBotX bot, String hostmask) {
			return new UserHostmask(bot, hostmask);
		}

		public UserHostmask createUserHostmask(PircBotX bot, String extbanPrefix, String nick, String login, String hostname) {
			return new UserHostmask(bot, extbanPrefix, nick, login, hostname);
		}

		public User createUser(UserHostmask userHostmask) {
			return new User(userHostmask);
		}

		public Channel createChannel(PircBotX bot, String name) {
			return new Channel(bot, name);
		}
	}

	public static class ServerEntry {
		@NonNull
		private final String hostname;
		private final int port;

		@Override
		public String toString() {
			return hostname + ":" + port;
		}

		@java.beans.ConstructorProperties({"hostname", "port"})
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public ServerEntry(@NonNull final String hostname, final int port) {
			if (hostname == null) {
				throw new java.lang.NullPointerException("hostname");
			}
			this.hostname = hostname;
			this.port = port;
		}

		@NonNull
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public String getHostname() {
			return this.hostname;
		}

		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int getPort() {
			return this.port;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public boolean equals(final java.lang.Object o) {
			if (o == this) return true;
			if (!(o instanceof Configuration.ServerEntry)) return false;
			final ServerEntry other = (ServerEntry)o;
			if (!other.canEqual((java.lang.Object)this)) return false;
			final java.lang.Object this$hostname = this.getHostname();
			final java.lang.Object other$hostname = other.getHostname();
			if (this$hostname == null ? other$hostname != null : !this$hostname.equals(other$hostname)) return false;
			if (this.getPort() != other.getPort()) return false;
			return true;
		}

		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		protected boolean canEqual(final java.lang.Object other) {
			return other instanceof Configuration.ServerEntry;
		}

		@java.lang.Override
		@java.lang.SuppressWarnings("all")
		@javax.annotation.Generated("lombok")
		public int hashCode() {
			final int PRIME = 59;
			int result = 1;
			final java.lang.Object $hostname = this.getHostname();
			result = result * PRIME + ($hostname == null ? 0 : $hostname.hashCode());
			result = result * PRIME + this.getPort();
			return result;
		}
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isWebIrcEnabled() {
		return this.webIrcEnabled;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getWebIrcUsername() {
		return this.webIrcUsername;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getWebIrcHostname() {
		return this.webIrcHostname;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public InetAddress getWebIrcAddress() {
		return this.webIrcAddress;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getWebIrcPassword() {
		return this.webIrcPassword;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getName() {
		return this.name;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getLogin() {
		return this.login;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getVersion() {
		return this.version;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getFinger() {
		return this.finger;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getRealName() {
		return this.realName;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getChannelPrefixes() {
		return this.channelPrefixes;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getUserLevelPrefixes() {
		return this.userLevelPrefixes;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isSnapshotsEnabled() {
		return this.snapshotsEnabled;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isDccFilenameQuotes() {
		return this.dccFilenameQuotes;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public ImmutableList<Integer> getDccPorts() {
		return this.dccPorts;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public InetAddress getDccLocalAddress() {
		return this.dccLocalAddress;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getDccAcceptTimeout() {
		return this.dccAcceptTimeout;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getDccResumeAcceptTimeout() {
		return this.dccResumeAcceptTimeout;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getDccTransferBufferSize() {
		return this.dccTransferBufferSize;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isDccPassiveRequest() {
		return this.dccPassiveRequest;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public ImmutableList<ServerEntry> getServers() {
		return this.servers;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getServerPassword() {
		return this.serverPassword;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public SocketFactory getSocketFactory() {
		return this.socketFactory;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public InetAddress getLocalAddress() {
		return this.localAddress;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public Charset getEncoding() {
		return this.encoding;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public Locale getLocale() {
		return this.locale;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getSocketTimeout() {
		return this.socketTimeout;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getMaxLineLength() {
		return this.maxLineLength;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isAutoSplitMessage() {
		return this.autoSplitMessage;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isAutoNickChange() {
		return this.autoNickChange;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public long getMessageDelay() {
		return this.messageDelay;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isShutdownHookEnabled() {
		return this.shutdownHookEnabled;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public ImmutableMap<String, String> getAutoJoinChannels() {
		return this.autoJoinChannels;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isIdentServerEnabled() {
		return this.identServerEnabled;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getNickservPassword() {
		return this.nickservPassword;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getNickservOnSuccess() {
		return this.nickservOnSuccess;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public String getNickservNick() {
		return this.nickservNick;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isNickservDelayJoin() {
		return this.nickservDelayJoin;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isAutoReconnect() {
		return this.autoReconnect;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getAutoReconnectDelay() {
		return this.autoReconnectDelay;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int getAutoReconnectAttempts() {
		return this.autoReconnectAttempts;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean isCapEnabled() {
		return this.capEnabled;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public ImmutableList<CapHandler> getCapHandlers() {
		return this.capHandlers;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public ImmutableSortedMap<Character, ChannelModeHandler> getChannelModeHandlers() {
		return this.channelModeHandlers;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public BotFactory getBotFactory() {
		return this.botFactory;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public boolean equals(final java.lang.Object o) {
		if (o == this) return true;
		if (!(o instanceof Configuration)) return false;
		final Configuration other = (Configuration)o;
		if (!other.canEqual((java.lang.Object)this)) return false;
		if (this.isWebIrcEnabled() != other.isWebIrcEnabled()) return false;
		final java.lang.Object this$webIrcUsername = this.getWebIrcUsername();
		final java.lang.Object other$webIrcUsername = other.getWebIrcUsername();
		if (this$webIrcUsername == null ? other$webIrcUsername != null : !this$webIrcUsername.equals(other$webIrcUsername)) return false;
		final java.lang.Object this$webIrcHostname = this.getWebIrcHostname();
		final java.lang.Object other$webIrcHostname = other.getWebIrcHostname();
		if (this$webIrcHostname == null ? other$webIrcHostname != null : !this$webIrcHostname.equals(other$webIrcHostname)) return false;
		final java.lang.Object this$webIrcAddress = this.getWebIrcAddress();
		final java.lang.Object other$webIrcAddress = other.getWebIrcAddress();
		if (this$webIrcAddress == null ? other$webIrcAddress != null : !this$webIrcAddress.equals(other$webIrcAddress)) return false;
		final java.lang.Object this$webIrcPassword = this.getWebIrcPassword();
		final java.lang.Object other$webIrcPassword = other.getWebIrcPassword();
		if (this$webIrcPassword == null ? other$webIrcPassword != null : !this$webIrcPassword.equals(other$webIrcPassword)) return false;
		final java.lang.Object this$name = this.getName();
		final java.lang.Object other$name = other.getName();
		if (this$name == null ? other$name != null : !this$name.equals(other$name)) return false;
		final java.lang.Object this$login = this.getLogin();
		final java.lang.Object other$login = other.getLogin();
		if (this$login == null ? other$login != null : !this$login.equals(other$login)) return false;
		final java.lang.Object this$version = this.getVersion();
		final java.lang.Object other$version = other.getVersion();
		if (this$version == null ? other$version != null : !this$version.equals(other$version)) return false;
		final java.lang.Object this$finger = this.getFinger();
		final java.lang.Object other$finger = other.getFinger();
		if (this$finger == null ? other$finger != null : !this$finger.equals(other$finger)) return false;
		final java.lang.Object this$realName = this.getRealName();
		final java.lang.Object other$realName = other.getRealName();
		if (this$realName == null ? other$realName != null : !this$realName.equals(other$realName)) return false;
		final java.lang.Object this$channelPrefixes = this.getChannelPrefixes();
		final java.lang.Object other$channelPrefixes = other.getChannelPrefixes();
		if (this$channelPrefixes == null ? other$channelPrefixes != null : !this$channelPrefixes.equals(other$channelPrefixes)) return false;
		final java.lang.Object this$userLevelPrefixes = this.getUserLevelPrefixes();
		final java.lang.Object other$userLevelPrefixes = other.getUserLevelPrefixes();
		if (this$userLevelPrefixes == null ? other$userLevelPrefixes != null : !this$userLevelPrefixes.equals(other$userLevelPrefixes)) return false;
		if (this.isSnapshotsEnabled() != other.isSnapshotsEnabled()) return false;
		if (this.isDccFilenameQuotes() != other.isDccFilenameQuotes()) return false;
		final java.lang.Object this$dccPorts = this.getDccPorts();
		final java.lang.Object other$dccPorts = other.getDccPorts();
		if (this$dccPorts == null ? other$dccPorts != null : !this$dccPorts.equals(other$dccPorts)) return false;
		final java.lang.Object this$dccLocalAddress = this.getDccLocalAddress();
		final java.lang.Object other$dccLocalAddress = other.getDccLocalAddress();
		if (this$dccLocalAddress == null ? other$dccLocalAddress != null : !this$dccLocalAddress.equals(other$dccLocalAddress)) return false;
		if (this.getDccAcceptTimeout() != other.getDccAcceptTimeout()) return false;
		if (this.getDccResumeAcceptTimeout() != other.getDccResumeAcceptTimeout()) return false;
		if (this.getDccTransferBufferSize() != other.getDccTransferBufferSize()) return false;
		if (this.isDccPassiveRequest() != other.isDccPassiveRequest()) return false;
		final java.lang.Object this$servers = this.getServers();
		final java.lang.Object other$servers = other.getServers();
		if (this$servers == null ? other$servers != null : !this$servers.equals(other$servers)) return false;
		final java.lang.Object this$serverPassword = this.getServerPassword();
		final java.lang.Object other$serverPassword = other.getServerPassword();
		if (this$serverPassword == null ? other$serverPassword != null : !this$serverPassword.equals(other$serverPassword)) return false;
		final java.lang.Object this$socketFactory = this.getSocketFactory();
		final java.lang.Object other$socketFactory = other.getSocketFactory();
		if (this$socketFactory == null ? other$socketFactory != null : !this$socketFactory.equals(other$socketFactory)) return false;
		final java.lang.Object this$localAddress = this.getLocalAddress();
		final java.lang.Object other$localAddress = other.getLocalAddress();
		if (this$localAddress == null ? other$localAddress != null : !this$localAddress.equals(other$localAddress)) return false;
		final java.lang.Object this$encoding = this.getEncoding();
		final java.lang.Object other$encoding = other.getEncoding();
		if (this$encoding == null ? other$encoding != null : !this$encoding.equals(other$encoding)) return false;
		final java.lang.Object this$locale = this.getLocale();
		final java.lang.Object other$locale = other.getLocale();
		if (this$locale == null ? other$locale != null : !this$locale.equals(other$locale)) return false;
		if (this.getSocketTimeout() != other.getSocketTimeout()) return false;
		if (this.getMaxLineLength() != other.getMaxLineLength()) return false;
		if (this.isAutoSplitMessage() != other.isAutoSplitMessage()) return false;
		if (this.isAutoNickChange() != other.isAutoNickChange()) return false;
		if (this.getMessageDelay() != other.getMessageDelay()) return false;
		if (this.isShutdownHookEnabled() != other.isShutdownHookEnabled()) return false;
		final java.lang.Object this$autoJoinChannels = this.getAutoJoinChannels();
		final java.lang.Object other$autoJoinChannels = other.getAutoJoinChannels();
		if (this$autoJoinChannels == null ? other$autoJoinChannels != null : !this$autoJoinChannels.equals(other$autoJoinChannels)) return false;
		if (this.isIdentServerEnabled() != other.isIdentServerEnabled()) return false;
		final java.lang.Object this$nickservPassword = this.getNickservPassword();
		final java.lang.Object other$nickservPassword = other.getNickservPassword();
		if (this$nickservPassword == null ? other$nickservPassword != null : !this$nickservPassword.equals(other$nickservPassword)) return false;
		final java.lang.Object this$nickservOnSuccess = this.getNickservOnSuccess();
		final java.lang.Object other$nickservOnSuccess = other.getNickservOnSuccess();
		if (this$nickservOnSuccess == null ? other$nickservOnSuccess != null : !this$nickservOnSuccess.equals(other$nickservOnSuccess)) return false;
		final java.lang.Object this$nickservNick = this.getNickservNick();
		final java.lang.Object other$nickservNick = other.getNickservNick();
		if (this$nickservNick == null ? other$nickservNick != null : !this$nickservNick.equals(other$nickservNick)) return false;
		if (this.isNickservDelayJoin() != other.isNickservDelayJoin()) return false;
		if (this.isAutoReconnect() != other.isAutoReconnect()) return false;
		if (this.getAutoReconnectDelay() != other.getAutoReconnectDelay()) return false;
		if (this.getAutoReconnectAttempts() != other.getAutoReconnectAttempts()) return false;
		final java.lang.Object this$listenerManager = this.getListenerManager();
		final java.lang.Object other$listenerManager = other.getListenerManager();
		if (this$listenerManager == null ? other$listenerManager != null : !this$listenerManager.equals(other$listenerManager)) return false;
		if (this.isCapEnabled() != other.isCapEnabled()) return false;
		final java.lang.Object this$capHandlers = this.getCapHandlers();
		final java.lang.Object other$capHandlers = other.getCapHandlers();
		if (this$capHandlers == null ? other$capHandlers != null : !this$capHandlers.equals(other$capHandlers)) return false;
		final java.lang.Object this$channelModeHandlers = this.getChannelModeHandlers();
		final java.lang.Object other$channelModeHandlers = other.getChannelModeHandlers();
		if (this$channelModeHandlers == null ? other$channelModeHandlers != null : !this$channelModeHandlers.equals(other$channelModeHandlers)) return false;
		final java.lang.Object this$botFactory = this.getBotFactory();
		final java.lang.Object other$botFactory = other.getBotFactory();
		if (this$botFactory == null ? other$botFactory != null : !this$botFactory.equals(other$botFactory)) return false;
		return true;
	}

	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	protected boolean canEqual(final java.lang.Object other) {
		return other instanceof Configuration;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public int hashCode() {
		final int PRIME = 59;
		int result = 1;
		result = result * PRIME + (this.isWebIrcEnabled() ? 79 : 97);
		final java.lang.Object $webIrcUsername = this.getWebIrcUsername();
		result = result * PRIME + ($webIrcUsername == null ? 0 : $webIrcUsername.hashCode());
		final java.lang.Object $webIrcHostname = this.getWebIrcHostname();
		result = result * PRIME + ($webIrcHostname == null ? 0 : $webIrcHostname.hashCode());
		final java.lang.Object $webIrcAddress = this.getWebIrcAddress();
		result = result * PRIME + ($webIrcAddress == null ? 0 : $webIrcAddress.hashCode());
		final java.lang.Object $webIrcPassword = this.getWebIrcPassword();
		result = result * PRIME + ($webIrcPassword == null ? 0 : $webIrcPassword.hashCode());
		final java.lang.Object $name = this.getName();
		result = result * PRIME + ($name == null ? 0 : $name.hashCode());
		final java.lang.Object $login = this.getLogin();
		result = result * PRIME + ($login == null ? 0 : $login.hashCode());
		final java.lang.Object $version = this.getVersion();
		result = result * PRIME + ($version == null ? 0 : $version.hashCode());
		final java.lang.Object $finger = this.getFinger();
		result = result * PRIME + ($finger == null ? 0 : $finger.hashCode());
		final java.lang.Object $realName = this.getRealName();
		result = result * PRIME + ($realName == null ? 0 : $realName.hashCode());
		final java.lang.Object $channelPrefixes = this.getChannelPrefixes();
		result = result * PRIME + ($channelPrefixes == null ? 0 : $channelPrefixes.hashCode());
		final java.lang.Object $userLevelPrefixes = this.getUserLevelPrefixes();
		result = result * PRIME + ($userLevelPrefixes == null ? 0 : $userLevelPrefixes.hashCode());
		result = result * PRIME + (this.isSnapshotsEnabled() ? 79 : 97);
		result = result * PRIME + (this.isDccFilenameQuotes() ? 79 : 97);
		final java.lang.Object $dccPorts = this.getDccPorts();
		result = result * PRIME + ($dccPorts == null ? 0 : $dccPorts.hashCode());
		final java.lang.Object $dccLocalAddress = this.getDccLocalAddress();
		result = result * PRIME + ($dccLocalAddress == null ? 0 : $dccLocalAddress.hashCode());
		result = result * PRIME + this.getDccAcceptTimeout();
		result = result * PRIME + this.getDccResumeAcceptTimeout();
		result = result * PRIME + this.getDccTransferBufferSize();
		result = result * PRIME + (this.isDccPassiveRequest() ? 79 : 97);
		final java.lang.Object $servers = this.getServers();
		result = result * PRIME + ($servers == null ? 0 : $servers.hashCode());
		final java.lang.Object $serverPassword = this.getServerPassword();
		result = result * PRIME + ($serverPassword == null ? 0 : $serverPassword.hashCode());
		final java.lang.Object $socketFactory = this.getSocketFactory();
		result = result * PRIME + ($socketFactory == null ? 0 : $socketFactory.hashCode());
		final java.lang.Object $localAddress = this.getLocalAddress();
		result = result * PRIME + ($localAddress == null ? 0 : $localAddress.hashCode());
		final java.lang.Object $encoding = this.getEncoding();
		result = result * PRIME + ($encoding == null ? 0 : $encoding.hashCode());
		final java.lang.Object $locale = this.getLocale();
		result = result * PRIME + ($locale == null ? 0 : $locale.hashCode());
		result = result * PRIME + this.getSocketTimeout();
		result = result * PRIME + this.getMaxLineLength();
		result = result * PRIME + (this.isAutoSplitMessage() ? 79 : 97);
		result = result * PRIME + (this.isAutoNickChange() ? 79 : 97);
		final long $messageDelay = this.getMessageDelay();
		result = result * PRIME + (int)($messageDelay >>> 32 ^ $messageDelay);
		result = result * PRIME + (this.isShutdownHookEnabled() ? 79 : 97);
		final java.lang.Object $autoJoinChannels = this.getAutoJoinChannels();
		result = result * PRIME + ($autoJoinChannels == null ? 0 : $autoJoinChannels.hashCode());
		result = result * PRIME + (this.isIdentServerEnabled() ? 79 : 97);
		final java.lang.Object $nickservPassword = this.getNickservPassword();
		result = result * PRIME + ($nickservPassword == null ? 0 : $nickservPassword.hashCode());
		final java.lang.Object $nickservOnSuccess = this.getNickservOnSuccess();
		result = result * PRIME + ($nickservOnSuccess == null ? 0 : $nickservOnSuccess.hashCode());
		final java.lang.Object $nickservNick = this.getNickservNick();
		result = result * PRIME + ($nickservNick == null ? 0 : $nickservNick.hashCode());
		result = result * PRIME + (this.isNickservDelayJoin() ? 79 : 97);
		result = result * PRIME + (this.isAutoReconnect() ? 79 : 97);
		result = result * PRIME + this.getAutoReconnectDelay();
		result = result * PRIME + this.getAutoReconnectAttempts();
		final java.lang.Object $listenerManager = this.getListenerManager();
		result = result * PRIME + ($listenerManager == null ? 0 : $listenerManager.hashCode());
		result = result * PRIME + (this.isCapEnabled() ? 79 : 97);
		final java.lang.Object $capHandlers = this.getCapHandlers();
		result = result * PRIME + ($capHandlers == null ? 0 : $capHandlers.hashCode());
		final java.lang.Object $channelModeHandlers = this.getChannelModeHandlers();
		result = result * PRIME + ($channelModeHandlers == null ? 0 : $channelModeHandlers.hashCode());
		final java.lang.Object $botFactory = this.getBotFactory();
		result = result * PRIME + ($botFactory == null ? 0 : $botFactory.hashCode());
		return result;
	}

	@java.lang.Override
	@java.lang.SuppressWarnings("all")
	@javax.annotation.Generated("lombok")
	public java.lang.String toString() {
		return "Configuration(webIrcEnabled=" + this.isWebIrcEnabled() + ", webIrcUsername=" + this.getWebIrcUsername() + ", webIrcHostname=" + this.getWebIrcHostname() + ", webIrcAddress=" + this.getWebIrcAddress() + ", webIrcPassword=" + this.getWebIrcPassword() + ", name=" + this.getName() + ", login=" + this.getLogin() + ", version=" + this.getVersion() + ", finger=" + this.getFinger() + ", realName=" + this.getRealName() + ", channelPrefixes=" + this.getChannelPrefixes() + ", userLevelPrefixes=" + this.getUserLevelPrefixes() + ", snapshotsEnabled=" + this.isSnapshotsEnabled() + ", dccFilenameQuotes=" + this.isDccFilenameQuotes() + ", dccPorts=" + this.getDccPorts() + ", dccLocalAddress=" + this.getDccLocalAddress() + ", dccAcceptTimeout=" + this.getDccAcceptTimeout() + ", dccResumeAcceptTimeout=" + this.getDccResumeAcceptTimeout() + ", dccTransferBufferSize=" + this.getDccTransferBufferSize() + ", dccPassiveRequest=" + this.isDccPassiveRequest() + ", servers=" + this.getServers() + ", socketFactory=" + this.getSocketFactory() + ", localAddress=" + this.getLocalAddress() + ", encoding=" + this.getEncoding() + ", locale=" + this.getLocale() + ", socketTimeout=" + this.getSocketTimeout() + ", maxLineLength=" + this.getMaxLineLength() + ", autoSplitMessage=" + this.isAutoSplitMessage() + ", autoNickChange=" + this.isAutoNickChange() + ", messageDelay=" + this.getMessageDelay() + ", shutdownHookEnabled=" + this.isShutdownHookEnabled() + ", autoJoinChannels=" + this.getAutoJoinChannels() + ", identServerEnabled=" + this.isIdentServerEnabled() + ", nickservOnSuccess=" + this.getNickservOnSuccess() + ", nickservNick=" + this.getNickservNick() + ", nickservDelayJoin=" + this.isNickservDelayJoin() + ", autoReconnect=" + this.isAutoReconnect() + ", autoReconnectDelay=" + this.getAutoReconnectDelay() + ", autoReconnectAttempts=" + this.getAutoReconnectAttempts() + ", listenerManager=" + this.getListenerManager() + ", capEnabled=" + this.isCapEnabled() + ", capHandlers=" + this.getCapHandlers() + ", channelModeHandlers=" + this.getChannelModeHandlers() + ", botFactory=" + this.getBotFactory() + ")";
	}
}